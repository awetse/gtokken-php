<!DOCTYPE html>
<!-- saved from url=(0038)http://192.168.0.3/1_bin/contract.html -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  
  <title></title>
  <link rel="stylesheet" href="http://192.168.0.3/1_bin/contract.html">
  <style>
  body{
  font-size:16px;
  font-family:courier, courier new, serif;
  }
  .line{
  display:inline-block;
  color:#999;
  width:3rem;
  text-align:right;
  margin-right:1rem;
  }
  .comment{
  font-style:italic;
  color:#aaa;
  }
  .reserved{
  font-weight:bold;
  color:blue;
  }
  code{
  color:black;
  }
  </style>
</head>
<body>
<code>
<span class="line">1</span> 
<br>
<span class="line">2</span> <span class="comment">/**
</span><br>
<span class="line">3</span> <span class="comment"> *Submitted for verification at Etherscan.io on 2021-06-14
</span><br>
<span class="line">4</span> <span class="comment">*/
</span><br>
<span class="line">5</span> 
<br>
<span class="line">6</span> <span class="comment">/**
</span><br>
<span class="line">7</span> <span class="comment"> *Submitted for verification at Etherscan.io on 2021-06-13
</span><br>
<span class="line">8</span> <span class="comment">*/
</span><br>
<span class="line">9</span> 
<br>
<span class="line">10</span> <span class="comment">/**
</span><br>
<span class="line">11</span> <span class="comment"> *Submitted for verification at Etherscan.io on 2021-06-12
</span><br>
<span class="line">12</span> <span class="comment">*/
</span><br>
<span class="line">13</span> 
<br>
<span class="line">14</span> <span class="comment">/**
</span><br>
<span class="line">15</span> <span class="comment"> *Submitted for verification at Etherscan.io on 2021-04-22
</span><br>
<span class="line">16</span> <span class="comment">*/
</span><br>
<span class="line">17</span> 
<br>
<span class="line">18</span> <span class="comment">// File: @openzeppelin/contracts/utils/Context.sol
</span><br>
<span class="line">19</span> 
<br>
<span class="line">20</span> <span class="comment">// SPDX-License-Identifier: MIT
</span><br>
<span class="line">21</span> 
<br>
<span class="line">22</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">23</span> 
<br>
<span class="line">24</span> <span class="comment">/*
</span><br>
<span class="line">25</span> <span class="comment"> * @dev Provides information about the current execution context, including the
</span><br>
<span class="line">26</span> <span class="comment"> * sender of the transaction and its data. While these are generally available
</span><br>
<span class="line">27</span> <span class="comment"> * via msg.sender and msg.data, they should not be accessed in such a direct
</span><br>
<span class="line">28</span> <span class="comment"> * manner, since when dealing with GSN meta-transactions the account sending and
</span><br>
<span class="line">29</span> <span class="comment"> * paying for execution may not be the actual sender (as far as an application
</span><br>
<span class="line">30</span> <span class="comment"> * is concerned).
</span><br>
<span class="line">31</span> <span class="comment"> *
</span><br>
<span class="line">32</span> <span class="comment"> * This contract is only required for intermediate, library-like contracts.
</span><br>
<span class="line">33</span> <span class="comment"> */
</span><br>
<span class="line">34</span> abstract contract Context {
<br>
<span class="line">35</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _msgSender() internal view virtual <span class="reserved">returns</span> (address payable) {
<br>
<span class="line">36</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">msg</span>.sender;
<br>
<span class="line">37</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">38</span> 
<br>
<span class="line">39</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _msgData() internal view virtual <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">40</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this; <span class="comment">// silence state mutability warning without generating bytecode - see https:github.com/ethereum/solidity/issues/2691
</span><br>
<span class="line">41</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">msg</span>.data;
<br>
<span class="line">42</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">43</span> }
<br>
<span class="line">44</span> 
<br>
<span class="line">45</span> <span class="comment">// File: @openzeppelin/contracts/introspection/IERC165.sol
</span><br>
<span class="line">46</span> 
<br>
<span class="line">47</span> 
<br>
<span class="line">48</span> 
<br>
<span class="line">49</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">50</span> 
<br>
<span class="line">51</span> <span class="comment">/**
</span><br>
<span class="line">52</span> <span class="comment"> * @dev Interface of the ERC165 standard, as defined in the
</span><br>
<span class="line">53</span> <span class="comment"> * https://eips.ethereum.org/EIPS/eip-165[EIP].
</span><br>
<span class="line">54</span> <span class="comment"> *
</span><br>
<span class="line">55</span> <span class="comment"> * Implementers can declare support of contract interfaces, which can then be
</span><br>
<span class="line">56</span> <span class="comment"> * queried by others ({ERC165Checker}).
</span><br>
<span class="line">57</span> <span class="comment"> *
</span><br>
<span class="line">58</span> <span class="comment"> * For an implementation, see {ERC165}.
</span><br>
<span class="line">59</span> <span class="comment"> */
</span><br>
<span class="line">60</span> interface IERC165 {
<br>
<span class="line">61</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">62</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if this contract implements the interface defined by
</span><br>
<span class="line">63</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `interfaceId`. See the corresponding
</span><br>
<span class="line">64</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
</span><br>
<span class="line">65</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * to learn more about how these ids are created.
</span><br>
<span class="line">66</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">67</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * This function call must use less than 30 000 gas.
</span><br>
<span class="line">68</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">69</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> supportsInterface(bytes4 <span class="reserved">interface</span>Id) external view <span class="reserved">returns</span> (bool);
<br>
<span class="line">70</span> }
<br>
<span class="line">71</span> 
<br>
<span class="line">72</span> <span class="comment">// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
</span><br>
<span class="line">73</span> 
<br>
<span class="line">74</span> 
<br>
<span class="line">75</span> 
<br>
<span class="line">76</span> pragma solidity &gt;=0.6.2 &lt;0.8.0;
<br>
<span class="line">77</span> 
<br>
<span class="line">78</span> 
<br>
<span class="line">79</span> <span class="comment">/**
</span><br>
<span class="line">80</span> <span class="comment"> * @dev Required interface of an ERC721 compliant contract.
</span><br>
<span class="line">81</span> <span class="comment"> */
</span><br>
<span class="line">82</span> interface IERC721 is IERC165 {
<br>
<span class="line">83</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">84</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
</span><br>
<span class="line">85</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">86</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">event</span> Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
<br>
<span class="line">87</span> 
<br>
<span class="line">88</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">89</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
</span><br>
<span class="line">90</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">91</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">event</span> Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
<br>
<span class="line">92</span> 
<br>
<span class="line">93</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">94</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
</span><br>
<span class="line">95</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">96</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">event</span> ApprovalForAll(address indexed owner, address indexed operator, bool approved);
<br>
<span class="line">97</span> 
<br>
<span class="line">98</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">99</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of tokens in ``owner``'s account.
</span><br>
<span class="line">100</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">101</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> balanceOf(address owner) external view <span class="reserved">returns</span> (uint256 balance);
<br>
<span class="line">102</span> 
<br>
<span class="line">103</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">104</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the owner of the `tokenId` token.
</span><br>
<span class="line">105</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">106</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">107</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">108</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">109</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">110</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> ownerOf(uint256 tokenId) external view <span class="reserved">returns</span> (address owner);
<br>
<span class="line">111</span> 
<br>
<span class="line">112</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">113</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
</span><br>
<span class="line">114</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * are aware of the ERC721 protocol to prevent tokens from being forever locked.
</span><br>
<span class="line">115</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">116</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">117</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">118</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `from` cannot be the zero address.
</span><br>
<span class="line">119</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">120</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` token must exist and be owned by `from`.
</span><br>
<span class="line">121</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
</span><br>
<span class="line">122</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
</span><br>
<span class="line">123</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">124</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">125</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">126</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> safeTransferFrom(address from, address to, uint256 tokenId) external;
<br>
<span class="line">127</span> 
<br>
<span class="line">128</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">129</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Transfers `tokenId` token from `from` to `to`.
</span><br>
<span class="line">130</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">131</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
</span><br>
<span class="line">132</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">133</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">134</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">135</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `from` cannot be the zero address.
</span><br>
<span class="line">136</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">137</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` token must be owned by `from`.
</span><br>
<span class="line">138</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
</span><br>
<span class="line">139</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">140</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">141</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">142</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> transferFrom(address from, address to, uint256 tokenId) external;
<br>
<span class="line">143</span> 
<br>
<span class="line">144</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">145</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Gives permission to `to` to transfer `tokenId` token to another account.
</span><br>
<span class="line">146</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * The approval is cleared when the token is transferred.
</span><br>
<span class="line">147</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">148</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
</span><br>
<span class="line">149</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">150</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">151</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">152</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The caller must own the token or be an approved operator.
</span><br>
<span class="line">153</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">154</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">155</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits an {Approval} event.
</span><br>
<span class="line">156</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">157</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> approve(address to, uint256 tokenId) external;
<br>
<span class="line">158</span> 
<br>
<span class="line">159</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">160</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the account approved for `tokenId` token.
</span><br>
<span class="line">161</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">162</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">163</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">164</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">165</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">166</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> getApproved(uint256 tokenId) external view <span class="reserved">returns</span> (address operator);
<br>
<span class="line">167</span> 
<br>
<span class="line">168</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">169</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Approve or remove `operator` as an operator for the caller.
</span><br>
<span class="line">170</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
</span><br>
<span class="line">171</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">172</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">173</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">174</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The `operator` cannot be the caller.
</span><br>
<span class="line">175</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">176</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits an {ApprovalForAll} event.
</span><br>
<span class="line">177</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">178</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> setApprovalForAll(address operator, bool _approved) external;
<br>
<span class="line">179</span> 
<br>
<span class="line">180</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">181</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
</span><br>
<span class="line">182</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">183</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * See {setApprovalForAll}
</span><br>
<span class="line">184</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">185</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> isApprovedForAll(address owner, address operator) external view <span class="reserved">returns</span> (bool);
<br>
<span class="line">186</span> 
<br>
<span class="line">187</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">188</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* @dev Safely transfers `tokenId` token from `from` to `to`.
</span><br>
<span class="line">189</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">190</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">191</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">192</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* - `from` cannot be the zero address.
</span><br>
<span class="line">193</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* - `to` cannot be the zero address.
</span><br>
<span class="line">194</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* - `tokenId` token must exist and be owned by `from`.
</span><br>
<span class="line">195</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
</span><br>
<span class="line">196</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
</span><br>
<span class="line">197</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">198</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Emits a {Transfer} event.
</span><br>
<span class="line">199</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">200</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> safeTransferFrom(address from, address to, uint256 tokenId, <span class="reserved">byte</span>s calldata data) external;
<br>
<span class="line">201</span> }
<br>
<span class="line">202</span> 
<br>
<span class="line">203</span> <span class="comment">// File: @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol
</span><br>
<span class="line">204</span> 
<br>
<span class="line">205</span> 
<br>
<span class="line">206</span> 
<br>
<span class="line">207</span> pragma solidity &gt;=0.6.2 &lt;0.8.0;
<br>
<span class="line">208</span> 
<br>
<span class="line">209</span> 
<br>
<span class="line">210</span> <span class="comment">/**
</span><br>
<span class="line">211</span> <span class="comment"> * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
</span><br>
<span class="line">212</span> <span class="comment"> * @dev See https://eips.ethereum.org/EIPS/eip-721
</span><br>
<span class="line">213</span> <span class="comment"> */
</span><br>
<span class="line">214</span> interface IERC721Metadata is IERC721 {
<br>
<span class="line">215</span> 
<br>
<span class="line">216</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">217</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the token collection name.
</span><br>
<span class="line">218</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">219</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> name() external view <span class="reserved">returns</span> (string memory);
<br>
<span class="line">220</span> 
<br>
<span class="line">221</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">222</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the token collection symbol.
</span><br>
<span class="line">223</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">224</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> symbol() external view <span class="reserved">returns</span> (string memory);
<br>
<span class="line">225</span> 
<br>
<span class="line">226</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">227</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
</span><br>
<span class="line">228</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">229</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenURI(uint256 tokenId) external view <span class="reserved">returns</span> (string memory);
<br>
<span class="line">230</span> }
<br>
<span class="line">231</span> 
<br>
<span class="line">232</span> <span class="comment">// File: @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol
</span><br>
<span class="line">233</span> 
<br>
<span class="line">234</span> 
<br>
<span class="line">235</span> 
<br>
<span class="line">236</span> pragma solidity &gt;=0.6.2 &lt;0.8.0;
<br>
<span class="line">237</span> 
<br>
<span class="line">238</span> 
<br>
<span class="line">239</span> <span class="comment">/**
</span><br>
<span class="line">240</span> <span class="comment"> * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
</span><br>
<span class="line">241</span> <span class="comment"> * @dev See https://eips.ethereum.org/EIPS/eip-721
</span><br>
<span class="line">242</span> <span class="comment"> */
</span><br>
<span class="line">243</span> interface IERC721Enumerable is IERC721 {
<br>
<span class="line">244</span> 
<br>
<span class="line">245</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">246</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the total amount of tokens stored by the contract.
</span><br>
<span class="line">247</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">248</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> totalSupply() external view <span class="reserved">returns</span> (uint256);
<br>
<span class="line">249</span> 
<br>
<span class="line">250</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">251</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
</span><br>
<span class="line">252</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
</span><br>
<span class="line">253</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">254</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenOfOwnerByIndex(address owner, uint256 index) external view <span class="reserved">returns</span> (uint256 tokenId);
<br>
<span class="line">255</span> 
<br>
<span class="line">256</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">257</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
</span><br>
<span class="line">258</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Use along with {totalSupply} to enumerate all tokens.
</span><br>
<span class="line">259</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">260</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenByIndex(uint256 index) external view <span class="reserved">returns</span> (uint256);
<br>
<span class="line">261</span> }
<br>
<span class="line">262</span> 
<br>
<span class="line">263</span> <span class="comment">// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
</span><br>
<span class="line">264</span> 
<br>
<span class="line">265</span> 
<br>
<span class="line">266</span> 
<br>
<span class="line">267</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">268</span> 
<br>
<span class="line">269</span> <span class="comment">/**
</span><br>
<span class="line">270</span> <span class="comment"> * @title ERC721 token receiver interface
</span><br>
<span class="line">271</span> <span class="comment"> * @dev Interface for any contract that wants to support safeTransfers
</span><br>
<span class="line">272</span> <span class="comment"> * from ERC721 asset contracts.
</span><br>
<span class="line">273</span> <span class="comment"> */
</span><br>
<span class="line">274</span> interface IERC721Receiver {
<br>
<span class="line">275</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">276</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
</span><br>
<span class="line">277</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * by `operator` from `from`, this function is called.
</span><br>
<span class="line">278</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">279</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * It must return its Solidity selector to confirm the token transfer.
</span><br>
<span class="line">280</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
</span><br>
<span class="line">281</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">282</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
</span><br>
<span class="line">283</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">284</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> onERC721Received(address operator, address from, uint256 tokenId, <span class="reserved">byte</span>s calldata data) external <span class="reserved">returns</span> (bytes4);
<br>
<span class="line">285</span> }
<br>
<span class="line">286</span> 
<br>
<span class="line">287</span> <span class="comment">// File: @openzeppelin/contracts/introspection/ERC165.sol
</span><br>
<span class="line">288</span> 
<br>
<span class="line">289</span> 
<br>
<span class="line">290</span> 
<br>
<span class="line">291</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">292</span> 
<br>
<span class="line">293</span> 
<br>
<span class="line">294</span> <span class="comment">/**
</span><br>
<span class="line">295</span> <span class="comment"> * @dev Implementation of the {IERC165} interface.
</span><br>
<span class="line">296</span> <span class="comment"> *
</span><br>
<span class="line">297</span> <span class="comment"> * Contracts may inherit from this and call {_registerInterface} to declare
</span><br>
<span class="line">298</span> <span class="comment"> * their support of an interface.
</span><br>
<span class="line">299</span> <span class="comment"> */
</span><br>
<span class="line">300</span> abstract contract ERC165 is IERC165 {
<br>
<span class="line">301</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/*
</span><br>
<span class="line">302</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
</span><br>
<span class="line">303</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">304</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 <span class="reserved">private</span> <span class="reserved">constant</span> _INTERFACE_ID_ERC165 = 0x01ffc9a7;
<br>
<span class="line">305</span> 
<br>
<span class="line">306</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">307</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Mapping of interface ids to whether or not it's supported.
</span><br>
<span class="line">308</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">309</span> &nbsp;&nbsp;&nbsp;&nbsp;mapping(bytes4 =&gt; bool) <span class="reserved">private</span> _supportedInterfaces;
<br>
<span class="line">310</span> 
<br>
<span class="line">311</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">constructor</span> () internal {
<br>
<span class="line">312</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Derived contracts need only register support for their own interfaces,
</span><br>
<span class="line">313</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// we register support for ERC165 itself here
</span><br>
<span class="line">314</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_registerInterface(_INTERFACE_ID_ERC165);
<br>
<span class="line">315</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">316</span> 
<br>
<span class="line">317</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">318</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC165-supportsInterface}.
</span><br>
<span class="line">319</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">320</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Time complexity O(1), guaranteed to always use less than 30 000 gas.
</span><br>
<span class="line">321</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">322</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> supportsInterface(bytes4 <span class="reserved">interface</span>Id) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (bool) {
<br>
<span class="line">323</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _supportedInterfaces[interfaceId];
<br>
<span class="line">324</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">325</span> 
<br>
<span class="line">326</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">327</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Registers the contract as an implementer of the interface defined by
</span><br>
<span class="line">328</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `interfaceId`. Support of the actual ERC165 interface is automatic and
</span><br>
<span class="line">329</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * registering its interface id is not required.
</span><br>
<span class="line">330</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">331</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * See {IERC165-supportsInterface}.
</span><br>
<span class="line">332</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">333</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">334</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">335</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).
</span><br>
<span class="line">336</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">337</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _registerInterface(bytes4 <span class="reserved">interface</span>Id) internal virtual {
<br>
<span class="line">338</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(interfaceId != 0xffffffff, "ERC165: invalid <span class="reserved">interface</span> id");
<br>
<span class="line">339</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_supportedInterfaces[interfaceId] = <span class="reserved">true</span>;
<br>
<span class="line">340</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">341</span> }
<br>
<span class="line">342</span> 
<br>
<span class="line">343</span> <span class="comment">// File: @openzeppelin/contracts/math/SafeMath.sol
</span><br>
<span class="line">344</span> 
<br>
<span class="line">345</span> 
<br>
<span class="line">346</span> 
<br>
<span class="line">347</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">348</span> 
<br>
<span class="line">349</span> <span class="comment">/**
</span><br>
<span class="line">350</span> <span class="comment"> * @dev Wrappers over Solidity's arithmetic operations with added overflow
</span><br>
<span class="line">351</span> <span class="comment"> * checks.
</span><br>
<span class="line">352</span> <span class="comment"> *
</span><br>
<span class="line">353</span> <span class="comment"> * Arithmetic operations in Solidity wrap on overflow. This can easily result
</span><br>
<span class="line">354</span> <span class="comment"> * in bugs, because programmers usually assume that an overflow raises an
</span><br>
<span class="line">355</span> <span class="comment"> * error, which is the standard behavior in high level programming languages.
</span><br>
<span class="line">356</span> <span class="comment"> * `SafeMath` restores this intuition by reverting the transaction when an
</span><br>
<span class="line">357</span> <span class="comment"> * operation overflows.
</span><br>
<span class="line">358</span> <span class="comment"> *
</span><br>
<span class="line">359</span> <span class="comment"> * Using this library instead of the unchecked operations eliminates an entire
</span><br>
<span class="line">360</span> <span class="comment"> * class of bugs, so it's recommended to use it always.
</span><br>
<span class="line">361</span> <span class="comment"> */
</span><br>
<span class="line">362</span> library SafeMath {
<br>
<span class="line">363</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">364</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the addition of two unsigned integers, with an overflow flag.
</span><br>
<span class="line">365</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">366</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">367</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">368</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Add(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (bool, uint256) {
<br>
<span class="line">369</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 c = a + b;
<br>
<span class="line">370</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (c &lt; a) <span class="reserved">return</span> (false, 0);
<br>
<span class="line">371</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (true, c);
<br>
<span class="line">372</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">373</span> 
<br>
<span class="line">374</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">375</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the substraction of two unsigned integers, with an overflow flag.
</span><br>
<span class="line">376</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">377</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">378</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">379</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Sub(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (bool, uint256) {
<br>
<span class="line">380</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (b &gt; a) <span class="reserved">return</span> (false, 0);
<br>
<span class="line">381</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (true, a - b);
<br>
<span class="line">382</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">383</span> 
<br>
<span class="line">384</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">385</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
</span><br>
<span class="line">386</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">387</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">388</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">389</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Mul(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (bool, uint256) {
<br>
<span class="line">390</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Gas optimization: this is cheaper than requiring 'a' not being zero, but the
</span><br>
<span class="line">391</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// benefit is lost if 'b' is also tested.
</span><br>
<span class="line">392</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// See: https:github.com/OpenZeppelin/openzeppelin-contracts/pull/522
</span><br>
<span class="line">393</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (a == 0) <span class="reserved">return</span> (true, 0);
<br>
<span class="line">394</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 c = a * b;
<br>
<span class="line">395</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (c / a != b) <span class="reserved">return</span> (false, 0);
<br>
<span class="line">396</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (true, c);
<br>
<span class="line">397</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">398</span> 
<br>
<span class="line">399</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">400</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the division of two unsigned integers, with a division by zero flag.
</span><br>
<span class="line">401</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">402</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">403</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">404</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Div(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (bool, uint256) {
<br>
<span class="line">405</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (b == 0) <span class="reserved">return</span> (false, 0);
<br>
<span class="line">406</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (true, a / b);
<br>
<span class="line">407</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">408</span> 
<br>
<span class="line">409</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">410</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
</span><br>
<span class="line">411</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">412</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">413</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">414</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Mod(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (bool, uint256) {
<br>
<span class="line">415</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (b == 0) <span class="reserved">return</span> (false, 0);
<br>
<span class="line">416</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (true, a % b);
<br>
<span class="line">417</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">418</span> 
<br>
<span class="line">419</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">420</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the addition of two unsigned integers, reverting on
</span><br>
<span class="line">421</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * overflow.
</span><br>
<span class="line">422</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">423</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `+` operator.
</span><br>
<span class="line">424</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">425</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">426</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">427</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - Addition cannot overflow.
</span><br>
<span class="line">428</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">429</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> add(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">430</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 c = a + b;
<br>
<span class="line">431</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(c &gt;= a, "SafeMath: addition overflow");
<br>
<span class="line">432</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> c;
<br>
<span class="line">433</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">434</span> 
<br>
<span class="line">435</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">436</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the subtraction of two unsigned integers, reverting on
</span><br>
<span class="line">437</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * overflow (when the result is negative).
</span><br>
<span class="line">438</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">439</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `-` operator.
</span><br>
<span class="line">440</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">441</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">442</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">443</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - Subtraction cannot overflow.
</span><br>
<span class="line">444</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">445</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> sub(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">446</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &lt;= a, "SafeMath: subtraction overflow");
<br>
<span class="line">447</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a - b;
<br>
<span class="line">448</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">449</span> 
<br>
<span class="line">450</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">451</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the multiplication of two unsigned integers, reverting on
</span><br>
<span class="line">452</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * overflow.
</span><br>
<span class="line">453</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">454</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `*` operator.
</span><br>
<span class="line">455</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">456</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">457</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">458</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - Multiplication cannot overflow.
</span><br>
<span class="line">459</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">460</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> mul(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">461</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (a == 0) <span class="reserved">return</span> 0;
<br>
<span class="line">462</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 c = a * b;
<br>
<span class="line">463</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(c / a == b, "SafeMath: multiplication overflow");
<br>
<span class="line">464</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> c;
<br>
<span class="line">465</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">466</span> 
<br>
<span class="line">467</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">468</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the integer division of two unsigned integers, reverting on
</span><br>
<span class="line">469</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * division by zero. The result is rounded towards zero.
</span><br>
<span class="line">470</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">471</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `/` operator. Note: this function uses a
</span><br>
<span class="line">472</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `revert` opcode (which leaves remaining gas untouched) while Solidity
</span><br>
<span class="line">473</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * uses an invalid opcode to revert (consuming all remaining gas).
</span><br>
<span class="line">474</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">475</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">476</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">477</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The divisor cannot be zero.
</span><br>
<span class="line">478</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">479</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> div(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">480</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &gt; 0, "SafeMath: division by zero");
<br>
<span class="line">481</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a / b;
<br>
<span class="line">482</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">483</span> 
<br>
<span class="line">484</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">485</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
</span><br>
<span class="line">486</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * reverting when dividing by zero.
</span><br>
<span class="line">487</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">488</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `%` operator. This function uses a `revert`
</span><br>
<span class="line">489</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * opcode (which leaves remaining gas untouched) while Solidity uses an
</span><br>
<span class="line">490</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * invalid opcode to revert (consuming all remaining gas).
</span><br>
<span class="line">491</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">492</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">493</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">494</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The divisor cannot be zero.
</span><br>
<span class="line">495</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">496</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> mod(uint256 a, uint256 b) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">497</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &gt; 0, "SafeMath: modulo by zero");
<br>
<span class="line">498</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a % b;
<br>
<span class="line">499</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">500</span> 
<br>
<span class="line">501</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">502</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
</span><br>
<span class="line">503</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * overflow (when the result is negative).
</span><br>
<span class="line">504</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">505</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * CAUTION: This function is deprecated because it requires allocating memory for the error
</span><br>
<span class="line">506</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * message unnecessarily. For custom revert reasons use {trySub}.
</span><br>
<span class="line">507</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">508</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `-` operator.
</span><br>
<span class="line">509</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">510</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">511</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">512</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - Subtraction cannot overflow.
</span><br>
<span class="line">513</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">514</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> sub(uint256 a, uint256 b, string memory errorMessage) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">515</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &lt;= a, errorMessage);
<br>
<span class="line">516</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a - b;
<br>
<span class="line">517</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">518</span> 
<br>
<span class="line">519</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">520</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the integer division of two unsigned integers, reverting with custom message on
</span><br>
<span class="line">521</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * division by zero. The result is rounded towards zero.
</span><br>
<span class="line">522</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">523</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * CAUTION: This function is deprecated because it requires allocating memory for the error
</span><br>
<span class="line">524</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * message unnecessarily. For custom revert reasons use {tryDiv}.
</span><br>
<span class="line">525</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">526</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `/` operator. Note: this function uses a
</span><br>
<span class="line">527</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `revert` opcode (which leaves remaining gas untouched) while Solidity
</span><br>
<span class="line">528</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * uses an invalid opcode to revert (consuming all remaining gas).
</span><br>
<span class="line">529</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">530</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">531</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">532</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The divisor cannot be zero.
</span><br>
<span class="line">533</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">534</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> div(uint256 a, uint256 b, string memory errorMessage) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">535</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &gt; 0, errorMessage);
<br>
<span class="line">536</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a / b;
<br>
<span class="line">537</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">538</span> 
<br>
<span class="line">539</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">540</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
</span><br>
<span class="line">541</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * reverting with custom message when dividing by zero.
</span><br>
<span class="line">542</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">543</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * CAUTION: This function is deprecated because it requires allocating memory for the error
</span><br>
<span class="line">544</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * message unnecessarily. For custom revert reasons use {tryMod}.
</span><br>
<span class="line">545</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">546</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Counterpart to Solidity's `%` operator. This function uses a `revert`
</span><br>
<span class="line">547</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * opcode (which leaves remaining gas untouched) while Solidity uses an
</span><br>
<span class="line">548</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * invalid opcode to revert (consuming all remaining gas).
</span><br>
<span class="line">549</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">550</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">551</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">552</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - The divisor cannot be zero.
</span><br>
<span class="line">553</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">554</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> mod(uint256 a, uint256 b, string memory errorMessage) internal pure <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">555</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(b &gt; 0, errorMessage);
<br>
<span class="line">556</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> a % b;
<br>
<span class="line">557</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">558</span> }
<br>
<span class="line">559</span> 
<br>
<span class="line">560</span> <span class="comment">// File: @openzeppelin/contracts/utils/Address.sol
</span><br>
<span class="line">561</span> 
<br>
<span class="line">562</span> 
<br>
<span class="line">563</span> 
<br>
<span class="line">564</span> pragma solidity &gt;=0.6.2 &lt;0.8.0;
<br>
<span class="line">565</span> 
<br>
<span class="line">566</span> <span class="comment">/**
</span><br>
<span class="line">567</span> <span class="comment"> * @dev Collection of functions related to the address type
</span><br>
<span class="line">568</span> <span class="comment"> */
</span><br>
<span class="line">569</span> library Address {
<br>
<span class="line">570</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">571</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if `account` is a contract.
</span><br>
<span class="line">572</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">573</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * [IMPORTANT]
</span><br>
<span class="line">574</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * ====
</span><br>
<span class="line">575</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * It is unsafe to assume that an address for which this function returns
</span><br>
<span class="line">576</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * false is an externally-owned account (EOA) and not a contract.
</span><br>
<span class="line">577</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">578</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Among others, `isContract` will return false for the following
</span><br>
<span class="line">579</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * types of addresses:
</span><br>
<span class="line">580</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">581</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;- an externally-owned account
</span><br>
<span class="line">582</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;- a contract in construction
</span><br>
<span class="line">583</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;- an address where a contract will be created
</span><br>
<span class="line">584</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;- an address where a contract lived, but was destroyed
</span><br>
<span class="line">585</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * ====
</span><br>
<span class="line">586</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">587</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> isContract(address account) internal view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">588</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// This method relies on extcodesize, which returns 0 for contracts in
</span><br>
<span class="line">589</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// construction, since the code is only stored at the end of the
</span><br>
<span class="line">590</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// constructor execution.
</span><br>
<span class="line">591</span> 
<br>
<span class="line">592</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 size;
<br>
<span class="line">593</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line no-inline-assembly
</span><br>
<span class="line">594</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assembly { size := extcodesize(account) }
<br>
<span class="line">595</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> size &gt; 0;
<br>
<span class="line">596</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">597</span> 
<br>
<span class="line">598</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">599</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
</span><br>
<span class="line">600</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `recipient`, forwarding all available gas and reverting on errors.
</span><br>
<span class="line">601</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">602</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
</span><br>
<span class="line">603</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * of certain opcodes, possibly making contracts go over the 2300 gas limit
</span><br>
<span class="line">604</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * imposed by `transfer`, making them unable to receive funds via
</span><br>
<span class="line">605</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `transfer`. {sendValue} removes this limitation.
</span><br>
<span class="line">606</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">607</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
</span><br>
<span class="line">608</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">609</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * IMPORTANT: because control is transferred to `recipient`, care must be
</span><br>
<span class="line">610</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * taken to not create reentrancy vulnerabilities. Consider using
</span><br>
<span class="line">611</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * {ReentrancyGuard} or the
</span><br>
<span class="line">612</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
</span><br>
<span class="line">613</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">614</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> sendValue(address payable recipient, uint256 amount) internal {
<br>
<span class="line">615</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(address(this).balance &gt;= amount, "Address: insufficient balance");
<br>
<span class="line">616</span> 
<br>
<span class="line">617</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line avoid-low-level-calls, avoid-call-value
</span><br>
<span class="line">618</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bool success, ) = recipient.call{ value: amount }("");
<br>
<span class="line">619</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(success, "Address: unable to send value, recipient may have reverted");
<br>
<span class="line">620</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">621</span> 
<br>
<span class="line">622</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">623</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Performs a Solidity function call using a low level `call`. A
</span><br>
<span class="line">624</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * plain`call` is an unsafe replacement for a function call: use this
</span><br>
<span class="line">625</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * function instead.
</span><br>
<span class="line">626</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">627</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * If `target` reverts with a revert reason, it is bubbled up by this
</span><br>
<span class="line">628</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * function (like regular Solidity function calls).
</span><br>
<span class="line">629</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">630</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns the raw returned data. To convert to the expected return value,
</span><br>
<span class="line">631</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
</span><br>
<span class="line">632</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">633</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">634</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">635</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `target` must be a contract.
</span><br>
<span class="line">636</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - calling `target` with `data` must not revert.
</span><br>
<span class="line">637</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">638</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.1._
</span><br>
<span class="line">639</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">640</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>Call(address target, <span class="reserved">byte</span>s memory data) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">641</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">function</span>Call(target, data, "Address: low-level call failed");
<br>
<span class="line">642</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">643</span> 
<br>
<span class="line">644</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">645</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
</span><br>
<span class="line">646</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `errorMessage` as a fallback revert reason when `target` reverts.
</span><br>
<span class="line">647</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">648</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.1._
</span><br>
<span class="line">649</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">650</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>Call(address target, <span class="reserved">byte</span>s memory data, string memory errorMessage) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">651</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">function</span>CallWithValue(target, data, 0, errorMessage);
<br>
<span class="line">652</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">653</span> 
<br>
<span class="line">654</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">655</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
</span><br>
<span class="line">656</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * but also transferring `value` wei to `target`.
</span><br>
<span class="line">657</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">658</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">659</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">660</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - the calling contract must have an ETH balance of at least `value`.
</span><br>
<span class="line">661</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - the called Solidity function must be `payable`.
</span><br>
<span class="line">662</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">663</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.1._
</span><br>
<span class="line">664</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">665</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>CallWithValue(address target, <span class="reserved">byte</span>s memory data, uint256 value) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">666</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">function</span>CallWithValue(target, data, value, "Address: low-level call with value failed");
<br>
<span class="line">667</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">668</span> 
<br>
<span class="line">669</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">670</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
</span><br>
<span class="line">671</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * with `errorMessage` as a fallback revert reason when `target` reverts.
</span><br>
<span class="line">672</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">673</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.1._
</span><br>
<span class="line">674</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">675</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>CallWithValue(address target, <span class="reserved">byte</span>s memory data, uint256 value, string memory errorMessage) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">676</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(address(this).balance &gt;= value, "Address: insufficient balance <span class="reserved">for</span> call");
<br>
<span class="line">677</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(isContract(target), "Address: call to non-contract");
<br>
<span class="line">678</span> 
<br>
<span class="line">679</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line avoid-low-level-calls
</span><br>
<span class="line">680</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bool success, <span class="reserved">byte</span>s memory <span class="reserved">return</span>data) = target.call{ value: value }(data);
<br>
<span class="line">681</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _verifyCallResult(success, <span class="reserved">return</span>data, errorMessage);
<br>
<span class="line">682</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">683</span> 
<br>
<span class="line">684</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">685</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
</span><br>
<span class="line">686</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * but performing a static call.
</span><br>
<span class="line">687</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">688</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.3._
</span><br>
<span class="line">689</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">690</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>StaticCall(address target, <span class="reserved">byte</span>s memory data) internal view <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">691</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">function</span>StaticCall(target, data, "Address: low-level <span class="reserved">static</span> call failed");
<br>
<span class="line">692</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">693</span> 
<br>
<span class="line">694</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">695</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
</span><br>
<span class="line">696</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * but performing a static call.
</span><br>
<span class="line">697</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">698</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.3._
</span><br>
<span class="line">699</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">700</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>StaticCall(address target, <span class="reserved">byte</span>s memory data, string memory errorMessage) internal view <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">701</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(isContract(target), "Address: <span class="reserved">static</span> call to non-contract");
<br>
<span class="line">702</span> 
<br>
<span class="line">703</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line avoid-low-level-calls
</span><br>
<span class="line">704</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bool success, <span class="reserved">byte</span>s memory <span class="reserved">return</span>data) = target.staticcall(data);
<br>
<span class="line">705</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _verifyCallResult(success, <span class="reserved">return</span>data, errorMessage);
<br>
<span class="line">706</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">707</span> 
<br>
<span class="line">708</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">709</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
</span><br>
<span class="line">710</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * but performing a delegate call.
</span><br>
<span class="line">711</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">712</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">713</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">714</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>DelegateCall(address target, <span class="reserved">byte</span>s memory data) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">715</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">function</span>DelegateCall(target, data, "Address: low-level delegate call failed");
<br>
<span class="line">716</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">717</span> 
<br>
<span class="line">718</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">719</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
</span><br>
<span class="line">720</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * but performing a delegate call.
</span><br>
<span class="line">721</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">722</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">723</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">724</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">function</span>DelegateCall(address target, <span class="reserved">byte</span>s memory data, string memory errorMessage) internal <span class="reserved">returns</span> (bytes memory) {
<br>
<span class="line">725</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(isContract(target), "Address: delegate call to non-contract");
<br>
<span class="line">726</span> 
<br>
<span class="line">727</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line avoid-low-level-calls
</span><br>
<span class="line">728</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bool success, <span class="reserved">byte</span>s memory <span class="reserved">return</span>data) = target.delegatecall(data);
<br>
<span class="line">729</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _verifyCallResult(success, <span class="reserved">return</span>data, errorMessage);
<br>
<span class="line">730</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">731</span> 
<br>
<span class="line">732</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _verifyCallResult(bool success, <span class="reserved">byte</span>s memory <span class="reserved">return</span>data, string memory errorMessage) <span class="reserved">private</span> pure <span class="reserved">returns</span>(bytes memory) {
<br>
<span class="line">733</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (success) {
<br>
<span class="line">734</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">return</span>data;
<br>
<span class="line">735</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">736</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Look for revert reason and bubble it up if present
</span><br>
<span class="line">737</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (returndata.length &gt; 0) {
<br>
<span class="line">738</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The easiest way to bubble the revert reason is using memory via assembly
</span><br>
<span class="line">739</span> 
<br>
<span class="line">740</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// solhint-disable-next-line no-inline-assembly
</span><br>
<span class="line">741</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assembly {
<br>
<span class="line">742</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let <span class="reserved">return</span>data_size := mload(returndata)
<br>
<span class="line">743</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;revert(add(32, <span class="reserved">return</span>data), <span class="reserved">return</span>data_size)
<br>
<span class="line">744</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">745</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">746</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;revert(errorMessage);
<br>
<span class="line">747</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">748</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">749</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">750</span> }
<br>
<span class="line">751</span> 
<br>
<span class="line">752</span> <span class="comment">// File: @openzeppelin/contracts/utils/EnumerableSet.sol
</span><br>
<span class="line">753</span> 
<br>
<span class="line">754</span> 
<br>
<span class="line">755</span> 
<br>
<span class="line">756</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">757</span> 
<br>
<span class="line">758</span> <span class="comment">/**
</span><br>
<span class="line">759</span> <span class="comment"> * @dev Library for managing
</span><br>
<span class="line">760</span> <span class="comment"> * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
</span><br>
<span class="line">761</span> <span class="comment"> * types.
</span><br>
<span class="line">762</span> <span class="comment"> *
</span><br>
<span class="line">763</span> <span class="comment"> * Sets have the following properties:
</span><br>
<span class="line">764</span> <span class="comment"> *
</span><br>
<span class="line">765</span> <span class="comment"> * - Elements are added, removed, and checked for existence in constant time
</span><br>
<span class="line">766</span> <span class="comment"> * (O(1)).
</span><br>
<span class="line">767</span> <span class="comment"> * - Elements are enumerated in O(n). No guarantees are made on the ordering.
</span><br>
<span class="line">768</span> <span class="comment"> *
</span><br>
<span class="line">769</span> <span class="comment"> * ```
</span><br>
<span class="line">770</span> <span class="comment"> * contract Example {
</span><br>
<span class="line">771</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; // Add the library methods
</span><br>
<span class="line">772</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; using EnumerableSet for EnumerableSet.AddressSet;
</span><br>
<span class="line">773</span> <span class="comment"> *
</span><br>
<span class="line">774</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; // Declare a set state variable
</span><br>
<span class="line">775</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; EnumerableSet.AddressSet private mySet;
</span><br>
<span class="line">776</span> <span class="comment"> * }
</span><br>
<span class="line">777</span> <span class="comment"> * ```
</span><br>
<span class="line">778</span> <span class="comment"> *
</span><br>
<span class="line">779</span> <span class="comment"> * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
</span><br>
<span class="line">780</span> <span class="comment"> * and `uint256` (`UintSet`) are supported.
</span><br>
<span class="line">781</span> <span class="comment"> */
</span><br>
<span class="line">782</span> library EnumerableSet {
<br>
<span class="line">783</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// To implement this library for multiple types with as little code
</span><br>
<span class="line">784</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// repetition as possible, we write it in terms of a generic Set type with
</span><br>
<span class="line">785</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// bytes32 values.
</span><br>
<span class="line">786</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The Set implementation uses private functions, and user-facing
</span><br>
<span class="line">787</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// implementations (such as AddressSet) are just wrappers around the
</span><br>
<span class="line">788</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// underlying Set.
</span><br>
<span class="line">789</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// This means that we can only create new EnumerableSets for types that fit
</span><br>
<span class="line">790</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// in bytes32.
</span><br>
<span class="line">791</span> 
<br>
<span class="line">792</span> &nbsp;&nbsp;&nbsp;&nbsp;struct Set {
<br>
<span class="line">793</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Storage of set values
</span><br>
<span class="line">794</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s32[] _values;
<br>
<span class="line">795</span> 
<br>
<span class="line">796</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Position of the value in the `values` array, plus 1 because index 0
</span><br>
<span class="line">797</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// means a value is not in the set.
</span><br>
<span class="line">798</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping (bytes32 =&gt; uint256) _indexes;
<br>
<span class="line">799</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">800</span> 
<br>
<span class="line">801</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">802</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Add a value to a set. O(1).
</span><br>
<span class="line">803</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">804</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was added to the set, that is if it was not
</span><br>
<span class="line">805</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">806</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">807</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _add(Set storage set, <span class="reserved">byte</span>s32 value) <span class="reserved">private</span> <span class="reserved">returns</span> (bool) {
<br>
<span class="line">808</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (!_contains(set, value)) {
<br>
<span class="line">809</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set._values.push(value);
<br>
<span class="line">810</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The value is stored at length-1, but we add 1 to all indexes
</span><br>
<span class="line">811</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// and use 0 as a sentinel value
</span><br>
<span class="line">812</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set._indexes[value] = set._values.length;
<br>
<span class="line">813</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">true</span>;
<br>
<span class="line">814</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">815</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">false</span>;
<br>
<span class="line">816</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">817</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">818</span> 
<br>
<span class="line">819</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">820</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a value from a set. O(1).
</span><br>
<span class="line">821</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">822</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was removed from the set, that is if it was
</span><br>
<span class="line">823</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * present.
</span><br>
<span class="line">824</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">825</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _remove(Set storage set, <span class="reserved">byte</span>s32 value) <span class="reserved">private</span> <span class="reserved">returns</span> (bool) {
<br>
<span class="line">826</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// We read and store the value's index to prevent multiple reads from the same storage slot
</span><br>
<span class="line">827</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 valueIndex = set._indexes[value];
<br>
<span class="line">828</span> 
<br>
<span class="line">829</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (valueIndex != 0) { <span class="comment">// Equivalent to contains(set, value)
</span><br>
<span class="line">830</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// To delete an element from the _values array in O(1), we swap the element to delete with the last one in
</span><br>
<span class="line">831</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// the array, and then remove the last element (sometimes called as 'swap and pop').
</span><br>
<span class="line">832</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// This modifies the order of the array, as noted in {at}.
</span><br>
<span class="line">833</span> 
<br>
<span class="line">834</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 toDeleteIndex = valueIndex - 1;
<br>
<span class="line">835</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 lastIndex = set._values.length - 1;
<br>
<span class="line">836</span> 
<br>
<span class="line">837</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
</span><br>
<span class="line">838</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.
</span><br>
<span class="line">839</span> 
<br>
<span class="line">840</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s32 lastvalue = set._values[lastIndex];
<br>
<span class="line">841</span> 
<br>
<span class="line">842</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Move the last value to the index where the value to delete is
</span><br>
<span class="line">843</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set._values[toDeleteIndex] = lastvalue;
<br>
<span class="line">844</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Update the index for the moved value
</span><br>
<span class="line">845</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set._indexes[lastvalue] = toDeleteIndex + 1; <span class="comment">// All indexes are 1-based
</span><br>
<span class="line">846</span> 
<br>
<span class="line">847</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Delete the slot where the moved value was stored
</span><br>
<span class="line">848</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set._values.pop();
<br>
<span class="line">849</span> 
<br>
<span class="line">850</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Delete the index for the deleted slot
</span><br>
<span class="line">851</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete set._indexes[value];
<br>
<span class="line">852</span> 
<br>
<span class="line">853</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">true</span>;
<br>
<span class="line">854</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">855</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">false</span>;
<br>
<span class="line">856</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">857</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">858</span> 
<br>
<span class="line">859</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">860</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the value is in the set. O(1).
</span><br>
<span class="line">861</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">862</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _contains(Set storage set, <span class="reserved">byte</span>s32 value) <span class="reserved">private</span> view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">863</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> set._indexes[value] != 0;
<br>
<span class="line">864</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">865</span> 
<br>
<span class="line">866</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">867</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of values on the set. O(1).
</span><br>
<span class="line">868</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">869</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _length(Set storage set) <span class="reserved">private</span> view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">870</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> set._values.length;
<br>
<span class="line">871</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">872</span> 
<br>
<span class="line">873</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">874</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the value stored at position `index` in the set. O(1).
</span><br>
<span class="line">875</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">876</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of values inside the
</span><br>
<span class="line">877</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more values are added or removed.
</span><br>
<span class="line">878</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">879</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">880</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">881</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">882</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">883</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _at(Set storage set, uint256 index) <span class="reserved">private</span> view <span class="reserved">returns</span> (bytes32) {
<br>
<span class="line">884</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(set._values.length &gt; index, "EnumerableSet: index out of bounds");
<br>
<span class="line">885</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> set._values[index];
<br>
<span class="line">886</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">887</span> 
<br>
<span class="line">888</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Bytes32Set
</span><br>
<span class="line">889</span> 
<br>
<span class="line">890</span> &nbsp;&nbsp;&nbsp;&nbsp;struct Bytes32Set {
<br>
<span class="line">891</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set _inner;
<br>
<span class="line">892</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">893</span> 
<br>
<span class="line">894</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">895</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Add a value to a set. O(1).
</span><br>
<span class="line">896</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">897</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was added to the set, that is if it was not
</span><br>
<span class="line">898</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">899</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">900</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> add(Bytes32Set storage set, <span class="reserved">byte</span>s32 value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">901</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _add(set._inner, value);
<br>
<span class="line">902</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">903</span> 
<br>
<span class="line">904</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">905</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a value from a set. O(1).
</span><br>
<span class="line">906</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">907</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was removed from the set, that is if it was
</span><br>
<span class="line">908</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * present.
</span><br>
<span class="line">909</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">910</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> remove(Bytes32Set storage set, <span class="reserved">byte</span>s32 value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">911</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _remove(set._inner, value);
<br>
<span class="line">912</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">913</span> 
<br>
<span class="line">914</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">915</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the value is in the set. O(1).
</span><br>
<span class="line">916</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">917</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> contains(Bytes32Set storage set, <span class="reserved">byte</span>s32 value) internal view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">918</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _contains(set._inner, value);
<br>
<span class="line">919</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">920</span> 
<br>
<span class="line">921</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">922</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of values in the set. O(1).
</span><br>
<span class="line">923</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">924</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> length(Bytes32Set storage set) internal view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">925</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _length(set._inner);
<br>
<span class="line">926</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">927</span> 
<br>
<span class="line">928</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">929</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the value stored at position `index` in the set. O(1).
</span><br>
<span class="line">930</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">931</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of values inside the
</span><br>
<span class="line">932</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more values are added or removed.
</span><br>
<span class="line">933</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">934</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">935</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">936</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">937</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">938</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> at(Bytes32Set storage set, uint256 index) internal view <span class="reserved">returns</span> (bytes32) {
<br>
<span class="line">939</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _at(set._inner, index);
<br>
<span class="line">940</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">941</span> 
<br>
<span class="line">942</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// AddressSet
</span><br>
<span class="line">943</span> 
<br>
<span class="line">944</span> &nbsp;&nbsp;&nbsp;&nbsp;struct AddressSet {
<br>
<span class="line">945</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set _inner;
<br>
<span class="line">946</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">947</span> 
<br>
<span class="line">948</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">949</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Add a value to a set. O(1).
</span><br>
<span class="line">950</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">951</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was added to the set, that is if it was not
</span><br>
<span class="line">952</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">953</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">954</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> add(AddressSet storage set, address value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">955</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _add(set._inner, <span class="reserved">byte</span>s32(uint256(uint160(value))));
<br>
<span class="line">956</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">957</span> 
<br>
<span class="line">958</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">959</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a value from a set. O(1).
</span><br>
<span class="line">960</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">961</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was removed from the set, that is if it was
</span><br>
<span class="line">962</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * present.
</span><br>
<span class="line">963</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">964</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> remove(AddressSet storage set, address value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">965</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _remove(set._inner, <span class="reserved">byte</span>s32(uint256(uint160(value))));
<br>
<span class="line">966</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">967</span> 
<br>
<span class="line">968</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">969</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the value is in the set. O(1).
</span><br>
<span class="line">970</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">971</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> contains(AddressSet storage set, address value) internal view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">972</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _contains(set._inner, <span class="reserved">byte</span>s32(uint256(uint160(value))));
<br>
<span class="line">973</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">974</span> 
<br>
<span class="line">975</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">976</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of values in the set. O(1).
</span><br>
<span class="line">977</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">978</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> length(AddressSet storage set) internal view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">979</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _length(set._inner);
<br>
<span class="line">980</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">981</span> 
<br>
<span class="line">982</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">983</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the value stored at position `index` in the set. O(1).
</span><br>
<span class="line">984</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">985</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of values inside the
</span><br>
<span class="line">986</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more values are added or removed.
</span><br>
<span class="line">987</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">988</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">989</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">990</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">991</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">992</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> at(AddressSet storage set, uint256 index) internal view <span class="reserved">returns</span> (address) {
<br>
<span class="line">993</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> address(uint160(uint256(_at(set._inner, index))));
<br>
<span class="line">994</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">995</span> 
<br>
<span class="line">996</span> 
<br>
<span class="line">997</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// UintSet
</span><br>
<span class="line">998</span> 
<br>
<span class="line">999</span> &nbsp;&nbsp;&nbsp;&nbsp;struct UintSet {
<br>
<span class="line">1000</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set _inner;
<br>
<span class="line">1001</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1002</span> 
<br>
<span class="line">1003</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1004</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Add a value to a set. O(1).
</span><br>
<span class="line">1005</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1006</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was added to the set, that is if it was not
</span><br>
<span class="line">1007</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">1008</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1009</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> add(UintSet storage set, uint256 value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1010</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _add(set._inner, <span class="reserved">byte</span>s32(value));
<br>
<span class="line">1011</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1012</span> 
<br>
<span class="line">1013</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1014</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a value from a set. O(1).
</span><br>
<span class="line">1015</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1016</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the value was removed from the set, that is if it was
</span><br>
<span class="line">1017</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * present.
</span><br>
<span class="line">1018</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1019</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> remove(UintSet storage set, uint256 value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1020</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _remove(set._inner, <span class="reserved">byte</span>s32(value));
<br>
<span class="line">1021</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1022</span> 
<br>
<span class="line">1023</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1024</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the value is in the set. O(1).
</span><br>
<span class="line">1025</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1026</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> contains(UintSet storage set, uint256 value) internal view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1027</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _contains(set._inner, <span class="reserved">byte</span>s32(value));
<br>
<span class="line">1028</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1029</span> 
<br>
<span class="line">1030</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1031</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of values on the set. O(1).
</span><br>
<span class="line">1032</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1033</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> length(UintSet storage set) internal view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1034</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _length(set._inner);
<br>
<span class="line">1035</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1036</span> 
<br>
<span class="line">1037</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">1038</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the value stored at position `index` in the set. O(1).
</span><br>
<span class="line">1039</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1040</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of values inside the
</span><br>
<span class="line">1041</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more values are added or removed.
</span><br>
<span class="line">1042</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1043</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">1044</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1045</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">1046</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">1047</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> at(UintSet storage set, uint256 index) internal view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1048</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> uint256(_at(set._inner, index));
<br>
<span class="line">1049</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1050</span> }
<br>
<span class="line">1051</span> 
<br>
<span class="line">1052</span> <span class="comment">// File: @openzeppelin/contracts/utils/EnumerableMap.sol
</span><br>
<span class="line">1053</span> 
<br>
<span class="line">1054</span> 
<br>
<span class="line">1055</span> 
<br>
<span class="line">1056</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">1057</span> 
<br>
<span class="line">1058</span> <span class="comment">/**
</span><br>
<span class="line">1059</span> <span class="comment"> * @dev Library for managing an enumerable variant of Solidity's
</span><br>
<span class="line">1060</span> <span class="comment"> * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
</span><br>
<span class="line">1061</span> <span class="comment"> * type.
</span><br>
<span class="line">1062</span> <span class="comment"> *
</span><br>
<span class="line">1063</span> <span class="comment"> * Maps have the following properties:
</span><br>
<span class="line">1064</span> <span class="comment"> *
</span><br>
<span class="line">1065</span> <span class="comment"> * - Entries are added, removed, and checked for existence in constant time
</span><br>
<span class="line">1066</span> <span class="comment"> * (O(1)).
</span><br>
<span class="line">1067</span> <span class="comment"> * - Entries are enumerated in O(n). No guarantees are made on the ordering.
</span><br>
<span class="line">1068</span> <span class="comment"> *
</span><br>
<span class="line">1069</span> <span class="comment"> * ```
</span><br>
<span class="line">1070</span> <span class="comment"> * contract Example {
</span><br>
<span class="line">1071</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; // Add the library methods
</span><br>
<span class="line">1072</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; using EnumerableMap for EnumerableMap.UintToAddressMap;
</span><br>
<span class="line">1073</span> <span class="comment"> *
</span><br>
<span class="line">1074</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; // Declare a set state variable
</span><br>
<span class="line">1075</span> <span class="comment"> *&nbsp;&nbsp;&nbsp;&nbsp; EnumerableMap.UintToAddressMap private myMap;
</span><br>
<span class="line">1076</span> <span class="comment"> * }
</span><br>
<span class="line">1077</span> <span class="comment"> * ```
</span><br>
<span class="line">1078</span> <span class="comment"> *
</span><br>
<span class="line">1079</span> <span class="comment"> * As of v3.0.0, only maps of type `uint256 -&gt; address` (`UintToAddressMap`) are
</span><br>
<span class="line">1080</span> <span class="comment"> * supported.
</span><br>
<span class="line">1081</span> <span class="comment"> */
</span><br>
<span class="line">1082</span> library EnumerableMap {
<br>
<span class="line">1083</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// To implement this library for multiple types with as little code
</span><br>
<span class="line">1084</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// repetition as possible, we write it in terms of a generic Map type with
</span><br>
<span class="line">1085</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// bytes32 keys and values.
</span><br>
<span class="line">1086</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The Map implementation uses private functions, and user-facing
</span><br>
<span class="line">1087</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// implementations (such as Uint256ToAddressMap) are just wrappers around
</span><br>
<span class="line">1088</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// the underlying Map.
</span><br>
<span class="line">1089</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// This means that we can only create new EnumerableMaps for types that fit
</span><br>
<span class="line">1090</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// in bytes32.
</span><br>
<span class="line">1091</span> 
<br>
<span class="line">1092</span> &nbsp;&nbsp;&nbsp;&nbsp;struct MapEntry {
<br>
<span class="line">1093</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s32 _key;
<br>
<span class="line">1094</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s32 _value;
<br>
<span class="line">1095</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1096</span> 
<br>
<span class="line">1097</span> &nbsp;&nbsp;&nbsp;&nbsp;struct Map {
<br>
<span class="line">1098</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Storage of map keys and values
</span><br>
<span class="line">1099</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapEntry[] _entries;
<br>
<span class="line">1100</span> 
<br>
<span class="line">1101</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Position of the entry defined by a key in the `entries` array, plus 1
</span><br>
<span class="line">1102</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// because index 0 means a key is not in the map.
</span><br>
<span class="line">1103</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping (bytes32 =&gt; uint256) _indexes;
<br>
<span class="line">1104</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1105</span> 
<br>
<span class="line">1106</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1107</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Adds a key-value pair to a map, or updates the value for an existing
</span><br>
<span class="line">1108</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * key. O(1).
</span><br>
<span class="line">1109</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1110</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the key was added to the map, that is if it was not
</span><br>
<span class="line">1111</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">1112</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1113</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _set(Map storage map, <span class="reserved">byte</span>s32 key, <span class="reserved">byte</span>s32 value) <span class="reserved">private</span> <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1114</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// We read and store the key's index to prevent multiple reads from the same storage slot
</span><br>
<span class="line">1115</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 keyIndex = map._indexes[key];
<br>
<span class="line">1116</span> 
<br>
<span class="line">1117</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (keyIndex == 0) { <span class="comment">// Equivalent to !contains(map, key)
</span><br>
<span class="line">1118</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._entries.push(MapEntry({ _key: key, _value: value }));
<br>
<span class="line">1119</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The entry is stored at length-1, but we add 1 to all indexes
</span><br>
<span class="line">1120</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// and use 0 as a sentinel value
</span><br>
<span class="line">1121</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._indexes[key] = map._entries.length;
<br>
<span class="line">1122</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">true</span>;
<br>
<span class="line">1123</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">1124</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._entries[keyIndex - 1]._value = value;
<br>
<span class="line">1125</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">false</span>;
<br>
<span class="line">1126</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1127</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1128</span> 
<br>
<span class="line">1129</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1130</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a key-value pair from a map. O(1).
</span><br>
<span class="line">1131</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1132</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the key was removed from the map, that is if it was present.
</span><br>
<span class="line">1133</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1134</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _remove(Map storage map, <span class="reserved">byte</span>s32 key) <span class="reserved">private</span> <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1135</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// We read and store the key's index to prevent multiple reads from the same storage slot
</span><br>
<span class="line">1136</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 keyIndex = map._indexes[key];
<br>
<span class="line">1137</span> 
<br>
<span class="line">1138</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (keyIndex != 0) { <span class="comment">// Equivalent to contains(map, key)
</span><br>
<span class="line">1139</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
</span><br>
<span class="line">1140</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// in the array, and then remove the last entry (sometimes called as 'swap and pop').
</span><br>
<span class="line">1141</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// This modifies the order of the array, as noted in {at}.
</span><br>
<span class="line">1142</span> 
<br>
<span class="line">1143</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 toDeleteIndex = keyIndex - 1;
<br>
<span class="line">1144</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 lastIndex = map._entries.length - 1;
<br>
<span class="line">1145</span> 
<br>
<span class="line">1146</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
</span><br>
<span class="line">1147</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.
</span><br>
<span class="line">1148</span> 
<br>
<span class="line">1149</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapEntry storage lastEntry = map._entries[lastIndex];
<br>
<span class="line">1150</span> 
<br>
<span class="line">1151</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Move the last entry to the index where the entry to delete is
</span><br>
<span class="line">1152</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._entries[toDeleteIndex] = lastEntry;
<br>
<span class="line">1153</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Update the index for the moved entry
</span><br>
<span class="line">1154</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._indexes[lastEntry._key] = toDeleteIndex + 1; <span class="comment">// All indexes are 1-based
</span><br>
<span class="line">1155</span> 
<br>
<span class="line">1156</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Delete the slot where the moved entry was stored
</span><br>
<span class="line">1157</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map._entries.pop();
<br>
<span class="line">1158</span> 
<br>
<span class="line">1159</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Delete the index for the deleted slot
</span><br>
<span class="line">1160</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete map._indexes[key];
<br>
<span class="line">1161</span> 
<br>
<span class="line">1162</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">true</span>;
<br>
<span class="line">1163</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <span class="reserved">else</span> {
<br>
<span class="line">1164</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">false</span>;
<br>
<span class="line">1165</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1166</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1167</span> 
<br>
<span class="line">1168</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1169</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the key is in the map. O(1).
</span><br>
<span class="line">1170</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1171</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _contains(Map storage map, <span class="reserved">byte</span>s32 key) <span class="reserved">private</span> view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1172</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> map._indexes[key] != 0;
<br>
<span class="line">1173</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1174</span> 
<br>
<span class="line">1175</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1176</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of key-value pairs in the map. O(1).
</span><br>
<span class="line">1177</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1178</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _length(Map storage map) <span class="reserved">private</span> view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1179</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> map._entries.length;
<br>
<span class="line">1180</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1181</span> 
<br>
<span class="line">1182</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">1183</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the key-value pair stored at position `index` in the map. O(1).
</span><br>
<span class="line">1184</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1185</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of entries inside the
</span><br>
<span class="line">1186</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more entries are added or removed.
</span><br>
<span class="line">1187</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1188</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">1189</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1190</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">1191</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">1192</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _at(Map storage map, uint256 index) <span class="reserved">private</span> view <span class="reserved">returns</span> (bytes32, <span class="reserved">byte</span>s32) {
<br>
<span class="line">1193</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(map._entries.length &gt; index, "EnumerableMap: index out of bounds");
<br>
<span class="line">1194</span> 
<br>
<span class="line">1195</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapEntry storage entry = map._entries[index];
<br>
<span class="line">1196</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (entry._key, entry._value);
<br>
<span class="line">1197</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1198</span> 
<br>
<span class="line">1199</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1200</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Tries to returns the value associated with `key`.&nbsp;&nbsp;O(1).
</span><br>
<span class="line">1201</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Does not revert if `key` is not in the map.
</span><br>
<span class="line">1202</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1203</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _tryGet(Map storage map, <span class="reserved">byte</span>s32 key) <span class="reserved">private</span> view <span class="reserved">returns</span> (bool, <span class="reserved">byte</span>s32) {
<br>
<span class="line">1204</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 keyIndex = map._indexes[key];
<br>
<span class="line">1205</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (keyIndex == 0) return (false, 0); <span class="comment">// Equivalent to contains(map, key)
</span><br>
<span class="line">1206</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (true, map._entries[keyIndex - 1]._value); <span class="comment">// All indexes are 1-based
</span><br>
<span class="line">1207</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1208</span> 
<br>
<span class="line">1209</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1210</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the value associated with `key`.&nbsp;&nbsp;O(1).
</span><br>
<span class="line">1211</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1212</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1213</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1214</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `key` must be in the map.
</span><br>
<span class="line">1215</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1216</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _get(Map storage map, <span class="reserved">byte</span>s32 key) <span class="reserved">private</span> view <span class="reserved">returns</span> (bytes32) {
<br>
<span class="line">1217</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 keyIndex = map._indexes[key];
<br>
<span class="line">1218</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(keyIndex != 0, "EnumerableMap: nonexistent key"); <span class="comment">// Equivalent to contains(map, key)
</span><br>
<span class="line">1219</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return map._entries[keyIndex - 1]._value; <span class="comment">// All indexes are 1-based
</span><br>
<span class="line">1220</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1221</span> 
<br>
<span class="line">1222</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1223</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {_get}, with a custom error message when `key` is not in the map.
</span><br>
<span class="line">1224</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1225</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * CAUTION: This function is deprecated because it requires allocating memory for the error
</span><br>
<span class="line">1226</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * message unnecessarily. For custom revert reasons use {_tryGet}.
</span><br>
<span class="line">1227</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1228</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _get(Map storage map, <span class="reserved">byte</span>s32 key, string memory errorMessage) <span class="reserved">private</span> view <span class="reserved">returns</span> (bytes32) {
<br>
<span class="line">1229</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 keyIndex = map._indexes[key];
<br>
<span class="line">1230</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(keyIndex != 0, errorMessage); <span class="comment">// Equivalent to contains(map, key)
</span><br>
<span class="line">1231</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return map._entries[keyIndex - 1]._value; <span class="comment">// All indexes are 1-based
</span><br>
<span class="line">1232</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1233</span> 
<br>
<span class="line">1234</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// UintToAddressMap
</span><br>
<span class="line">1235</span> 
<br>
<span class="line">1236</span> &nbsp;&nbsp;&nbsp;&nbsp;struct UintToAddressMap {
<br>
<span class="line">1237</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map _inner;
<br>
<span class="line">1238</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1239</span> 
<br>
<span class="line">1240</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1241</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Adds a key-value pair to a map, or updates the value for an existing
</span><br>
<span class="line">1242</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * key. O(1).
</span><br>
<span class="line">1243</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1244</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the key was added to the map, that is if it was not
</span><br>
<span class="line">1245</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * already present.
</span><br>
<span class="line">1246</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1247</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> set(UintToAddressMap storage map, uint256 key, address value) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1248</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _set(map._inner, <span class="reserved">byte</span>s32(key), <span class="reserved">byte</span>s32(uint256(uint160(value))));
<br>
<span class="line">1249</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1250</span> 
<br>
<span class="line">1251</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1252</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Removes a value from a set. O(1).
</span><br>
<span class="line">1253</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1254</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Returns true if the key was removed from the map, that is if it was present.
</span><br>
<span class="line">1255</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1256</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> remove(UintToAddressMap storage map, uint256 key) internal <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1257</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _remove(map._inner, <span class="reserved">byte</span>s32(key));
<br>
<span class="line">1258</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1259</span> 
<br>
<span class="line">1260</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1261</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns true if the key is in the map. O(1).
</span><br>
<span class="line">1262</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1263</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> contains(UintToAddressMap storage map, uint256 key) internal view <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1264</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _contains(map._inner, <span class="reserved">byte</span>s32(key));
<br>
<span class="line">1265</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1266</span> 
<br>
<span class="line">1267</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1268</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the number of elements in the map. O(1).
</span><br>
<span class="line">1269</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1270</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> length(UintToAddressMap storage map) internal view <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1271</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _length(map._inner);
<br>
<span class="line">1272</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1273</span> 
<br>
<span class="line">1274</span> <span class="comment">&nbsp;&nbsp; /**
</span><br>
<span class="line">1275</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the element stored at position `index` in the set. O(1).
</span><br>
<span class="line">1276</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Note that there are no guarantees on the ordering of values inside the
</span><br>
<span class="line">1277</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* array, and it may change when more values are added or removed.
</span><br>
<span class="line">1278</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1279</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* Requirements:
</span><br>
<span class="line">1280</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*
</span><br>
<span class="line">1281</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* - `index` must be strictly less than {length}.
</span><br>
<span class="line">1282</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">1283</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> at(UintToAddressMap storage map, uint256 index) internal view <span class="reserved">returns</span> (uint256, address) {
<br>
<span class="line">1284</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bytes32 key, <span class="reserved">byte</span>s32 value) = _at(map._inner, index);
<br>
<span class="line">1285</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (uint256(key), address(uint160(uint256(value))));
<br>
<span class="line">1286</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1287</span> 
<br>
<span class="line">1288</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1289</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Tries to returns the value associated with `key`.&nbsp;&nbsp;O(1).
</span><br>
<span class="line">1290</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Does not revert if `key` is not in the map.
</span><br>
<span class="line">1291</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1292</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * _Available since v3.4._
</span><br>
<span class="line">1293</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1294</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> <span class="reserved">try</span>Get(UintToAddressMap storage map, uint256 key) internal view <span class="reserved">returns</span> (bool, address) {
<br>
<span class="line">1295</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bool success, <span class="reserved">byte</span>s32 value) = _tryGet(map._inner, <span class="reserved">byte</span>s32(key));
<br>
<span class="line">1296</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (success, address(uint160(uint256(value))));
<br>
<span class="line">1297</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1298</span> 
<br>
<span class="line">1299</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1300</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the value associated with `key`.&nbsp;&nbsp;O(1).
</span><br>
<span class="line">1301</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1302</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1303</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1304</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `key` must be in the map.
</span><br>
<span class="line">1305</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1306</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> get(UintToAddressMap storage map, uint256 key) internal view <span class="reserved">returns</span> (address) {
<br>
<span class="line">1307</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> address(uint160(uint256(_get(map._inner, <span class="reserved">byte</span>s32(key)))));
<br>
<span class="line">1308</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1309</span> 
<br>
<span class="line">1310</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1311</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {get}, with a custom error message when `key` is not in the map.
</span><br>
<span class="line">1312</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1313</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * CAUTION: This function is deprecated because it requires allocating memory for the error
</span><br>
<span class="line">1314</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * message unnecessarily. For custom revert reasons use {tryGet}.
</span><br>
<span class="line">1315</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1316</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view <span class="reserved">returns</span> (address) {
<br>
<span class="line">1317</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> address(uint160(uint256(_get(map._inner, <span class="reserved">byte</span>s32(key), errorMessage))));
<br>
<span class="line">1318</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1319</span> }
<br>
<span class="line">1320</span> 
<br>
<span class="line">1321</span> <span class="comment">// File: @openzeppelin/contracts/utils/Strings.sol
</span><br>
<span class="line">1322</span> 
<br>
<span class="line">1323</span> 
<br>
<span class="line">1324</span> 
<br>
<span class="line">1325</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">1326</span> 
<br>
<span class="line">1327</span> <span class="comment">/**
</span><br>
<span class="line">1328</span> <span class="comment"> * @dev String operations.
</span><br>
<span class="line">1329</span> <span class="comment"> */
</span><br>
<span class="line">1330</span> library Strings {
<br>
<span class="line">1331</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1332</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Converts a `uint256` to its ASCII `string` representation.
</span><br>
<span class="line">1333</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1334</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> toString(uint256 value) internal pure <span class="reserved">returns</span> (string memory) {
<br>
<span class="line">1335</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Inspired by OraclizeAPI's implementation - MIT licence
</span><br>
<span class="line">1336</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// https:github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
</span><br>
<span class="line">1337</span> 
<br>
<span class="line">1338</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (value == 0) {
<br>
<span class="line">1339</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> "0";
<br>
<span class="line">1340</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1341</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 temp = value;
<br>
<span class="line">1342</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 digits;
<br>
<span class="line">1343</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">while</span> (temp != 0) {
<br>
<span class="line">1344</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;digits++;
<br>
<span class="line">1345</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp /= 10;
<br>
<span class="line">1346</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1347</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s memory buffer = <span class="reserved">new</span> <span class="reserved">byte</span>s(digits);
<br>
<span class="line">1348</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint256 index = digits - 1;
<br>
<span class="line">1349</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp = value;
<br>
<span class="line">1350</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">while</span> (temp != 0) {
<br>
<span class="line">1351</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[index--] = <span class="reserved">byte</span>s1(uint8(48 + temp % 10));
<br>
<span class="line">1352</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp /= 10;
<br>
<span class="line">1353</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1354</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> string(buffer);
<br>
<span class="line">1355</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1356</span> }
<br>
<span class="line">1357</span> 
<br>
<span class="line">1358</span> <span class="comment">// File: @openzeppelin/contracts/token/ERC721/ERC721.sol
</span><br>
<span class="line">1359</span> 
<br>
<span class="line">1360</span> 
<br>
<span class="line">1361</span> 
<br>
<span class="line">1362</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">1363</span> 
<br>
<span class="line">1364</span> 
<br>
<span class="line">1365</span> 
<br>
<span class="line">1366</span> 
<br>
<span class="line">1367</span> 
<br>
<span class="line">1368</span> 
<br>
<span class="line">1369</span> 
<br>
<span class="line">1370</span> 
<br>
<span class="line">1371</span> 
<br>
<span class="line">1372</span> 
<br>
<span class="line">1373</span> 
<br>
<span class="line">1374</span> 
<br>
<span class="line">1375</span> <span class="comment">/**
</span><br>
<span class="line">1376</span> <span class="comment"> * @title ERC721 Non-Fungible Token Standard basic implementation
</span><br>
<span class="line">1377</span> <span class="comment"> * @dev see https://eips.ethereum.org/EIPS/eip-721
</span><br>
<span class="line">1378</span> <span class="comment"> */
</span><br>
<span class="line">1379</span> contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
<br>
<span class="line">1380</span> &nbsp;&nbsp;&nbsp;&nbsp;using SafeMath <span class="reserved">for</span> uint256;
<br>
<span class="line">1381</span> &nbsp;&nbsp;&nbsp;&nbsp;using Address <span class="reserved">for</span> address;
<br>
<span class="line">1382</span> &nbsp;&nbsp;&nbsp;&nbsp;using EnumerableSet <span class="reserved">for</span> EnumerableSet.UintSet;
<br>
<span class="line">1383</span> &nbsp;&nbsp;&nbsp;&nbsp;using EnumerableMap <span class="reserved">for</span> EnumerableMap.UintToAddressMap;
<br>
<span class="line">1384</span> &nbsp;&nbsp;&nbsp;&nbsp;using Strings <span class="reserved">for</span> uint256;
<br>
<span class="line">1385</span> 
<br>
<span class="line">1386</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
</span><br>
<span class="line">1387</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`
</span><br>
<span class="line">1388</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 <span class="reserved">private</span> <span class="reserved">constant</span> _ERC721_RECEIVED = 0x150b7a02;
<br>
<span class="line">1389</span> 
<br>
<span class="line">1390</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Mapping from holder address to their (enumerable) set of owned tokens
</span><br>
<span class="line">1391</span> &nbsp;&nbsp;&nbsp;&nbsp;mapping (address =&gt; EnumerableSet.UintSet) <span class="reserved">private</span> _holderTokens;
<br>
<span class="line">1392</span> 
<br>
<span class="line">1393</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Enumerable mapping from token ids to their owners
</span><br>
<span class="line">1394</span> &nbsp;&nbsp;&nbsp;&nbsp;EnumerableMap.UintToAddressMap <span class="reserved">private</span> _tokenOwners;
<br>
<span class="line">1395</span> 
<br>
<span class="line">1396</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Mapping from token ID to approved address
</span><br>
<span class="line">1397</span> &nbsp;&nbsp;&nbsp;&nbsp;mapping (uint256 =&gt; address) <span class="reserved">private</span> _tokenApprovals;
<br>
<span class="line">1398</span> 
<br>
<span class="line">1399</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Mapping from owner to operator approvals
</span><br>
<span class="line">1400</span> &nbsp;&nbsp;&nbsp;&nbsp;mapping (address =&gt; mapping (address =&gt; bool)) <span class="reserved">private</span> _operatorApprovals;
<br>
<span class="line">1401</span> 
<br>
<span class="line">1402</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Token name
</span><br>
<span class="line">1403</span> &nbsp;&nbsp;&nbsp;&nbsp;string <span class="reserved">private</span> _name;
<br>
<span class="line">1404</span> 
<br>
<span class="line">1405</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Token symbol
</span><br>
<span class="line">1406</span> &nbsp;&nbsp;&nbsp;&nbsp;string <span class="reserved">private</span> _symbol;
<br>
<span class="line">1407</span> 
<br>
<span class="line">1408</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Optional mapping for token URIs
</span><br>
<span class="line">1409</span> &nbsp;&nbsp;&nbsp;&nbsp;mapping (uint256 =&gt; string) <span class="reserved">private</span> _tokenURIs;
<br>
<span class="line">1410</span> 
<br>
<span class="line">1411</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Base URI
</span><br>
<span class="line">1412</span> &nbsp;&nbsp;&nbsp;&nbsp;string <span class="reserved">private</span> _baseURI;
<br>
<span class="line">1413</span> 
<br>
<span class="line">1414</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/*
</span><br>
<span class="line">1415</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('balanceOf(address)')) == 0x70a08231
</span><br>
<span class="line">1416</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e
</span><br>
<span class="line">1417</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3
</span><br>
<span class="line">1418</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('getApproved(uint256)')) == 0x081812fc
</span><br>
<span class="line">1419</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465
</span><br>
<span class="line">1420</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5
</span><br>
<span class="line">1421</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd
</span><br>
<span class="line">1422</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
</span><br>
<span class="line">1423</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde
</span><br>
<span class="line">1424</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1425</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; =&gt; 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^
</span><br>
<span class="line">1426</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd
</span><br>
<span class="line">1427</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1428</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 <span class="reserved">private</span> <span class="reserved">constant</span> _INTERFACE_ID_ERC721 = 0x80ac58cd;
<br>
<span class="line">1429</span> 
<br>
<span class="line">1430</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/*
</span><br>
<span class="line">1431</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('name()')) == 0x06fdde03
</span><br>
<span class="line">1432</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('symbol()')) == 0x95d89b41
</span><br>
<span class="line">1433</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd
</span><br>
<span class="line">1434</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1435</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; =&gt; 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f
</span><br>
<span class="line">1436</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1437</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 <span class="reserved">private</span> <span class="reserved">constant</span> _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;
<br>
<span class="line">1438</span> 
<br>
<span class="line">1439</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/*
</span><br>
<span class="line">1440</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('totalSupply()')) == 0x18160ddd
</span><br>
<span class="line">1441</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59
</span><br>
<span class="line">1442</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7
</span><br>
<span class="line">1443</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1444</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp; =&gt; 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63
</span><br>
<span class="line">1445</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1446</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 <span class="reserved">private</span> <span class="reserved">constant</span> _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;
<br>
<span class="line">1447</span> 
<br>
<span class="line">1448</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1449</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
</span><br>
<span class="line">1450</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1451</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">constructor</span> (string memory name_, string memory symbol_) <span class="reserved">public</span> {
<br>
<span class="line">1452</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_name = name_;
<br>
<span class="line">1453</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_symbol = symbol_;
<br>
<span class="line">1454</span> 
<br>
<span class="line">1455</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// register the supported interfaces to conform to ERC721 via ERC165
</span><br>
<span class="line">1456</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_registerInterface(_INTERFACE_ID_ERC721);
<br>
<span class="line">1457</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_registerInterface(_INTERFACE_ID_ERC721_METADATA);
<br>
<span class="line">1458</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);
<br>
<span class="line">1459</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1460</span> 
<br>
<span class="line">1461</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1462</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-balanceOf}.
</span><br>
<span class="line">1463</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1464</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> balanceOf(address owner) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1465</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(owner != address(0), "ERC721: balance query <span class="reserved">for</span> the zero address");
<br>
<span class="line">1466</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _holderTokens[owner].length();
<br>
<span class="line">1467</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1468</span> 
<br>
<span class="line">1469</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1470</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-ownerOf}.
</span><br>
<span class="line">1471</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1472</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> ownerOf(uint256 tokenId) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (address) {
<br>
<span class="line">1473</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _tokenOwners.get(tokenId, "ERC721: owner query <span class="reserved">for</span> nonexistent token");
<br>
<span class="line">1474</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1475</span> 
<br>
<span class="line">1476</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1477</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Metadata-name}.
</span><br>
<span class="line">1478</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1479</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> name() <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (string memory) {
<br>
<span class="line">1480</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _name;
<br>
<span class="line">1481</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1482</span> 
<br>
<span class="line">1483</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1484</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Metadata-symbol}.
</span><br>
<span class="line">1485</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1486</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> symbol() <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (string memory) {
<br>
<span class="line">1487</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _symbol;
<br>
<span class="line">1488</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1489</span> 
<br>
<span class="line">1490</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1491</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Metadata-tokenURI}.
</span><br>
<span class="line">1492</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1493</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenURI(uint256 tokenId) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (string memory) {
<br>
<span class="line">1494</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_exists(tokenId), "ERC721Metadata: URI query <span class="reserved">for</span> nonexistent token");
<br>
<span class="line">1495</span> 
<br>
<span class="line">1496</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string memory _tokenURI = _tokenURIs[tokenId];
<br>
<span class="line">1497</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string memory base = baseURI();
<br>
<span class="line">1498</span> 
<br>
<span class="line">1499</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// If there is no base URI, return the token URI.
</span><br>
<span class="line">1500</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (bytes(base).length == 0) {
<br>
<span class="line">1501</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _tokenURI;
<br>
<span class="line">1502</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1503</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
</span><br>
<span class="line">1504</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (bytes(_tokenURI).length &gt; 0) {
<br>
<span class="line">1505</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> string(abi.encodePacked(base, _tokenURI));
<br>
<span class="line">1506</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1507</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.
</span><br>
<span class="line">1508</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> string(abi.encodePacked(base, tokenId.toString()));
<br>
<span class="line">1509</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1510</span> 
<br>
<span class="line">1511</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1512</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* @dev Returns the base URI set via {_setBaseURI}. This will be
</span><br>
<span class="line">1513</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* automatically added as a prefix in {tokenURI} to each token's URI, or
</span><br>
<span class="line">1514</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;* to the token ID if no specific URI is set for that token ID.
</span><br>
<span class="line">1515</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;*/
</span><br>
<span class="line">1516</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> baseURI() <span class="reserved">public</span> view virtual <span class="reserved">returns</span> (string memory) {
<br>
<span class="line">1517</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _baseURI;
<br>
<span class="line">1518</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1519</span> 
<br>
<span class="line">1520</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1521</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
</span><br>
<span class="line">1522</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1523</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenOfOwnerByIndex(address owner, uint256 index) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1524</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _holderTokens[owner].at(index);
<br>
<span class="line">1525</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1526</span> 
<br>
<span class="line">1527</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1528</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Enumerable-totalSupply}.
</span><br>
<span class="line">1529</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1530</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> totalSupply() <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1531</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds
</span><br>
<span class="line">1532</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _tokenOwners.length();
<br>
<span class="line">1533</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1534</span> 
<br>
<span class="line">1535</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1536</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721Enumerable-tokenByIndex}.
</span><br>
<span class="line">1537</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1538</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> tokenByIndex(uint256 index) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (uint256) {
<br>
<span class="line">1539</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(uint256 tokenId, ) = _tokenOwners.at(index);
<br>
<span class="line">1540</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> tokenId;
<br>
<span class="line">1541</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1542</span> 
<br>
<span class="line">1543</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1544</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-approve}.
</span><br>
<span class="line">1545</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1546</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> approve(address to, uint256 tokenId) <span class="reserved">public</span> virtual override {
<br>
<span class="line">1547</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address owner = ERC721.ownerOf(tokenId);
<br>
<span class="line">1548</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(to != owner, "ERC721: approval to current owner");
<br>
<span class="line">1549</span> 
<br>
<span class="line">1550</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),
<br>
<span class="line">1551</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ERC721: approve caller is not owner nor approved <span class="reserved">for</span> all"
<br>
<span class="line">1552</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
<br>
<span class="line">1553</span> 
<br>
<span class="line">1554</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_approve(to, tokenId);
<br>
<span class="line">1555</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1556</span> 
<br>
<span class="line">1557</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1558</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-getApproved}.
</span><br>
<span class="line">1559</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1560</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> getApproved(uint256 tokenId) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (address) {
<br>
<span class="line">1561</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_exists(tokenId), "ERC721: approved query <span class="reserved">for</span> nonexistent token");
<br>
<span class="line">1562</span> 
<br>
<span class="line">1563</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _tokenApprovals[tokenId];
<br>
<span class="line">1564</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1565</span> 
<br>
<span class="line">1566</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1567</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-setApprovalForAll}.
</span><br>
<span class="line">1568</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1569</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> setApprovalForAll(address operator, bool approved) <span class="reserved">public</span> virtual override {
<br>
<span class="line">1570</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(operator != _msgSender(), "ERC721: approve to caller");
<br>
<span class="line">1571</span> 
<br>
<span class="line">1572</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_operatorApprovals[_msgSender()][operator] = approved;
<br>
<span class="line">1573</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit ApprovalForAll(_msgSender(), operator, approved);
<br>
<span class="line">1574</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1575</span> 
<br>
<span class="line">1576</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1577</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-isApprovedForAll}.
</span><br>
<span class="line">1578</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1579</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> isApprovedForAll(address owner, address operator) <span class="reserved">public</span> view virtual override <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1580</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _operatorApprovals[owner][operator];
<br>
<span class="line">1581</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1582</span> 
<br>
<span class="line">1583</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1584</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-transferFrom}.
</span><br>
<span class="line">1585</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1586</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> transferFrom(address from, address to, uint256 tokenId) <span class="reserved">public</span> virtual override {
<br>
<span class="line">1587</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//solhint-disable-next-line max-line-length
</span><br>
<span class="line">1588</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
<br>
<span class="line">1589</span> 
<br>
<span class="line">1590</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_transfer(from, to, tokenId);
<br>
<span class="line">1591</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1592</span> 
<br>
<span class="line">1593</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1594</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-safeTransferFrom}.
</span><br>
<span class="line">1595</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1596</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> safeTransferFrom(address from, address to, uint256 tokenId) <span class="reserved">public</span> virtual override {
<br>
<span class="line">1597</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;safeTransferFrom(from, to, tokenId, "");
<br>
<span class="line">1598</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1599</span> 
<br>
<span class="line">1600</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1601</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev See {IERC721-safeTransferFrom}.
</span><br>
<span class="line">1602</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1603</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> safeTransferFrom(address from, address to, uint256 tokenId, <span class="reserved">byte</span>s memory _data) <span class="reserved">public</span> virtual override {
<br>
<span class="line">1604</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
<br>
<span class="line">1605</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_safeTransfer(from, to, tokenId, _data);
<br>
<span class="line">1606</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1607</span> 
<br>
<span class="line">1608</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1609</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
</span><br>
<span class="line">1610</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * are aware of the ERC721 protocol to prevent tokens from being forever locked.
</span><br>
<span class="line">1611</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1612</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `_data` is additional data, it has no specified format and it is sent in call to `to`.
</span><br>
<span class="line">1613</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1614</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
</span><br>
<span class="line">1615</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * implement alternative mechanisms to perform token transfer, such as signature-based.
</span><br>
<span class="line">1616</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1617</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1618</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1619</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `from` cannot be the zero address.
</span><br>
<span class="line">1620</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">1621</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` token must exist and be owned by `from`.
</span><br>
<span class="line">1622</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
</span><br>
<span class="line">1623</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1624</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">1625</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1626</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _safeTransfer(address from, address to, uint256 tokenId, <span class="reserved">byte</span>s memory _data) internal virtual {
<br>
<span class="line">1627</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_transfer(from, to, tokenId);
<br>
<span class="line">1628</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
<br>
<span class="line">1629</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1630</span> 
<br>
<span class="line">1631</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1632</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns whether `tokenId` exists.
</span><br>
<span class="line">1633</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1634</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
</span><br>
<span class="line">1635</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1636</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Tokens start existing when they are minted (`_mint`),
</span><br>
<span class="line">1637</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * and stop existing when they are burned (`_burn`).
</span><br>
<span class="line">1638</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1639</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _exists(uint256 tokenId) internal view virtual <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1640</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _tokenOwners.contains(tokenId);
<br>
<span class="line">1641</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1642</span> 
<br>
<span class="line">1643</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1644</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns whether `spender` is allowed to manage `tokenId`.
</span><br>
<span class="line">1645</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1646</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1647</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1648</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">1649</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1650</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual <span class="reserved">returns</span> (bool) {
<br>
<span class="line">1651</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_exists(tokenId), "ERC721: operator query <span class="reserved">for</span> nonexistent token");
<br>
<span class="line">1652</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address owner = ERC721.ownerOf(tokenId);
<br>
<span class="line">1653</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));
<br>
<span class="line">1654</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1655</span> 
<br>
<span class="line">1656</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1657</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Safely mints `tokenId` and transfers it to `to`.
</span><br>
<span class="line">1658</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1659</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1660</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; d*
</span><br>
<span class="line">1661</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must not exist.
</span><br>
<span class="line">1662</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
</span><br>
<span class="line">1663</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1664</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">1665</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1666</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _safeMint(address to, uint256 tokenId) internal virtual {
<br>
<span class="line">1667</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_safeMint(to, tokenId, "");
<br>
<span class="line">1668</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1669</span> 
<br>
<span class="line">1670</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1671</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
</span><br>
<span class="line">1672</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
</span><br>
<span class="line">1673</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1674</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _safeMint(address to, uint256 tokenId, <span class="reserved">byte</span>s memory _data) internal virtual {
<br>
<span class="line">1675</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_mint(to, tokenId);
<br>
<span class="line">1676</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
<br>
<span class="line">1677</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1678</span> 
<br>
<span class="line">1679</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1680</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Mints `tokenId` and transfers it to `to`.
</span><br>
<span class="line">1681</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1682</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
</span><br>
<span class="line">1683</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1684</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1685</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1686</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must not exist.
</span><br>
<span class="line">1687</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">1688</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1689</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">1690</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1691</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _mint(address to, uint256 tokenId) internal virtual {
<br>
<span class="line">1692</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(to != address(0), "ERC721: mint to the zero address");
<br>
<span class="line">1693</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(!_exists(tokenId), "ERC721: token already minted");
<br>
<span class="line">1694</span> 
<br>
<span class="line">1695</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_beforeTokenTransfer(address(0), to, tokenId);
<br>
<span class="line">1696</span> 
<br>
<span class="line">1697</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_holderTokens[to].add(tokenId);
<br>
<span class="line">1698</span> 
<br>
<span class="line">1699</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tokenOwners.set(tokenId, to);
<br>
<span class="line">1700</span> 
<br>
<span class="line">1701</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit Transfer(address(0), to, tokenId);
<br>
<span class="line">1702</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1703</span> 
<br>
<span class="line">1704</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1705</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Destroys `tokenId`.
</span><br>
<span class="line">1706</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * The approval is cleared when the token is burned.
</span><br>
<span class="line">1707</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1708</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1709</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1710</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">1711</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1712</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">1713</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1714</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _burn(uint256 tokenId) internal virtual {
<br>
<span class="line">1715</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address owner = ERC721.ownerOf(tokenId); <span class="comment">// internal owner
</span><br>
<span class="line">1716</span> 
<br>
<span class="line">1717</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_beforeTokenTransfer(owner, address(0), tokenId);
<br>
<span class="line">1718</span> 
<br>
<span class="line">1719</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Clear approvals
</span><br>
<span class="line">1720</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_approve(address(0), tokenId);
<br>
<span class="line">1721</span> 
<br>
<span class="line">1722</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Clear metadata (if any)
</span><br>
<span class="line">1723</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (bytes(_tokenURIs[tokenId]).length != 0) {
<br>
<span class="line">1724</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete _tokenURIs[tokenId];
<br>
<span class="line">1725</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1726</span> 
<br>
<span class="line">1727</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_holderTokens[owner].remove(tokenId);
<br>
<span class="line">1728</span> 
<br>
<span class="line">1729</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tokenOwners.remove(tokenId);
<br>
<span class="line">1730</span> 
<br>
<span class="line">1731</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit Transfer(owner, address(0), tokenId);
<br>
<span class="line">1732</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1733</span> 
<br>
<span class="line">1734</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1735</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Transfers `tokenId` from `from` to `to`.
</span><br>
<span class="line">1736</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
</span><br>
<span class="line">1737</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1738</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1739</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1740</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">1741</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` token must be owned by `from`.
</span><br>
<span class="line">1742</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1743</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits a {Transfer} event.
</span><br>
<span class="line">1744</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1745</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _transfer(address from, address to, uint256 tokenId) internal virtual {
<br>
<span class="line">1746</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own"); <span class="comment">// internal owner
</span><br>
<span class="line">1747</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(to != address(0), "ERC721: transfer to the zero address");
<br>
<span class="line">1748</span> 
<br>
<span class="line">1749</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_beforeTokenTransfer(from, to, tokenId);
<br>
<span class="line">1750</span> 
<br>
<span class="line">1751</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Clear approvals from the previous owner
</span><br>
<span class="line">1752</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_approve(address(0), tokenId);
<br>
<span class="line">1753</span> 
<br>
<span class="line">1754</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_holderTokens[from].remove(tokenId);
<br>
<span class="line">1755</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_holderTokens[to].add(tokenId);
<br>
<span class="line">1756</span> 
<br>
<span class="line">1757</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tokenOwners.set(tokenId, to);
<br>
<span class="line">1758</span> 
<br>
<span class="line">1759</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit Transfer(from, to, tokenId);
<br>
<span class="line">1760</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1761</span> 
<br>
<span class="line">1762</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1763</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
</span><br>
<span class="line">1764</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1765</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Requirements:
</span><br>
<span class="line">1766</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1767</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `tokenId` must exist.
</span><br>
<span class="line">1768</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1769</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
<br>
<span class="line">1770</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");
<br>
<span class="line">1771</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tokenURIs[tokenId] = _tokenURI;
<br>
<span class="line">1772</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1773</span> 
<br>
<span class="line">1774</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1775</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Internal function to set the base URI for all token IDs. It is
</span><br>
<span class="line">1776</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * automatically added as a prefix to the value returned in {tokenURI},
</span><br>
<span class="line">1777</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * or to the token ID if {tokenURI} is empty.
</span><br>
<span class="line">1778</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1779</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _setBaseURI(string memory baseURI_) internal virtual {
<br>
<span class="line">1780</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_baseURI = baseURI_;
<br>
<span class="line">1781</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1782</span> 
<br>
<span class="line">1783</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1784</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
</span><br>
<span class="line">1785</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * The call is not executed if the target address is not a contract.
</span><br>
<span class="line">1786</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1787</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @param from address representing the previous owner of the given token ID
</span><br>
<span class="line">1788</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @param to target address that will receive the tokens
</span><br>
<span class="line">1789</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @param tokenId uint256 ID of the token to be transferred
</span><br>
<span class="line">1790</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @param _data bytes optional data to send along with the call
</span><br>
<span class="line">1791</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @return bool whether the call correctly returned the expected magic value
</span><br>
<span class="line">1792</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1793</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _checkOnERC721Received(address from, address to, uint256 tokenId, <span class="reserved">byte</span>s memory _data)
<br>
<span class="line">1794</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">private</span> <span class="reserved">returns</span> (bool)
<br>
<span class="line">1795</span> &nbsp;&nbsp;&nbsp;&nbsp;{
<br>
<span class="line">1796</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (!to.isContract()) {
<br>
<span class="line">1797</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> <span class="reserved">true</span>;
<br>
<span class="line">1798</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1799</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s memory <span class="reserved">return</span>data = to.functionCall(abi.encodeWithSelector(
<br>
<span class="line">1800</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IERC721Receiver(to).onERC721Received.selector,
<br>
<span class="line">1801</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_msgSender(),
<br>
<span class="line">1802</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from,
<br>
<span class="line">1803</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenId,
<br>
<span class="line">1804</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_data
<br>
<span class="line">1805</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;), "ERC721: transfer to non ERC721Receiver implementer");
<br>
<span class="line">1806</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">byte</span>s4 retval = abi.decode(returndata, (bytes4));
<br>
<span class="line">1807</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> (retval == _ERC721_RECEIVED);
<br>
<span class="line">1808</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1809</span> 
<br>
<span class="line">1810</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1811</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Approve `to` to operate on `tokenId`
</span><br>
<span class="line">1812</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1813</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Emits an {Approval} event.
</span><br>
<span class="line">1814</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1815</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _approve(address to, uint256 tokenId) internal virtual {
<br>
<span class="line">1816</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tokenApprovals[tokenId] = to;
<br>
<span class="line">1817</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit Approval(ERC721.ownerOf(tokenId), to, tokenId); <span class="comment">// internal owner
</span><br>
<span class="line">1818</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1819</span> 
<br>
<span class="line">1820</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1821</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Hook that is called before any token transfer. This includes minting
</span><br>
<span class="line">1822</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * and burning.
</span><br>
<span class="line">1823</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1824</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Calling conditions:
</span><br>
<span class="line">1825</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1826</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
</span><br>
<span class="line">1827</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * transferred to `to`.
</span><br>
<span class="line">1828</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - When `from` is zero, `tokenId` will be minted for `to`.
</span><br>
<span class="line">1829</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - When `to` is zero, ``from``'s `tokenId` will be burned.
</span><br>
<span class="line">1830</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `from` cannot be the zero address.
</span><br>
<span class="line">1831</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * - `to` cannot be the zero address.
</span><br>
<span class="line">1832</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1833</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
</span><br>
<span class="line">1834</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1835</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }
<br>
<span class="line">1836</span> }
<br>
<span class="line">1837</span> 
<br>
<span class="line">1838</span> <span class="comment">// File: @openzeppelin/contracts/access/Ownable.sol
</span><br>
<span class="line">1839</span> 
<br>
<span class="line">1840</span> 
<br>
<span class="line">1841</span> 
<br>
<span class="line">1842</span> pragma solidity &gt;=0.6.0 &lt;0.8.0;
<br>
<span class="line">1843</span> 
<br>
<span class="line">1844</span> <span class="comment">/**
</span><br>
<span class="line">1845</span> <span class="comment"> * @dev Contract module which provides a basic access control mechanism, where
</span><br>
<span class="line">1846</span> <span class="comment"> * there is an account (an owner) that can be granted exclusive access to
</span><br>
<span class="line">1847</span> <span class="comment"> * specific functions.
</span><br>
<span class="line">1848</span> <span class="comment"> *
</span><br>
<span class="line">1849</span> <span class="comment"> * By default, the owner account will be the one that deploys the contract. This
</span><br>
<span class="line">1850</span> <span class="comment"> * can later be changed with {transferOwnership}.
</span><br>
<span class="line">1851</span> <span class="comment"> *
</span><br>
<span class="line">1852</span> <span class="comment"> * This module is used through inheritance. It will make available the modifier
</span><br>
<span class="line">1853</span> <span class="comment"> * `onlyOwner`, which can be applied to your functions to restrict their use to
</span><br>
<span class="line">1854</span> <span class="comment"> * the owner.
</span><br>
<span class="line">1855</span> <span class="comment"> */
</span><br>
<span class="line">1856</span> abstract contract Ownable is Context {
<br>
<span class="line">1857</span> &nbsp;&nbsp;&nbsp;&nbsp;address <span class="reserved">private</span> _owner;
<br>
<span class="line">1858</span> 
<br>
<span class="line">1859</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">event</span> OwnershipTransferred(address indexed previousOwner, address indexed <span class="reserved">new</span>Owner);
<br>
<span class="line">1860</span> 
<br>
<span class="line">1861</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1862</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Initializes the contract setting the deployer as the initial owner.
</span><br>
<span class="line">1863</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1864</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">constructor</span> () internal {
<br>
<span class="line">1865</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address <span class="reserved">msg</span>Sender = _msgSender();
<br>
<span class="line">1866</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_owner = <span class="reserved">msg</span>Sender;
<br>
<span class="line">1867</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit OwnershipTransferred(address(0), <span class="reserved">msg</span>Sender);
<br>
<span class="line">1868</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1869</span> 
<br>
<span class="line">1870</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1871</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Returns the address of the current owner.
</span><br>
<span class="line">1872</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1873</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> owner() <span class="reserved">public</span> view virtual <span class="reserved">returns</span> (address) {
<br>
<span class="line">1874</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">return</span> _owner;
<br>
<span class="line">1875</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1876</span> 
<br>
<span class="line">1877</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1878</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Throws if called by any account other than the owner.
</span><br>
<span class="line">1879</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1880</span> &nbsp;&nbsp;&nbsp;&nbsp;modifier onlyOwner() {
<br>
<span class="line">1881</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(owner() == _msgSender(), "Ownable: caller is not the owner");
<br>
<span class="line">1882</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_;
<br>
<span class="line">1883</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1884</span> 
<br>
<span class="line">1885</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1886</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Leaves the contract without owner. It will not be possible to call
</span><br>
<span class="line">1887</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * `onlyOwner` functions anymore. Can only be called by the current owner.
</span><br>
<span class="line">1888</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; *
</span><br>
<span class="line">1889</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * NOTE: Renouncing ownership will leave the contract without an owner,
</span><br>
<span class="line">1890</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * thereby removing any functionality that is only available to the owner.
</span><br>
<span class="line">1891</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1892</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> renounceOwnership() <span class="reserved">public</span> virtual onlyOwner {
<br>
<span class="line">1893</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit OwnershipTransferred(_owner, address(0));
<br>
<span class="line">1894</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_owner = address(0);
<br>
<span class="line">1895</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1896</span> 
<br>
<span class="line">1897</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;/**
</span><br>
<span class="line">1898</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * @dev Transfers ownership of the contract to a new account (`newOwner`).
</span><br>
<span class="line">1899</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; * Can only be called by the current owner.
</span><br>
<span class="line">1900</span> <span class="comment">&nbsp;&nbsp;&nbsp;&nbsp; */
</span><br>
<span class="line">1901</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> transferOwnership(address <span class="reserved">new</span>Owner) <span class="reserved">public</span> virtual onlyOwner {
<br>
<span class="line">1902</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(newOwner != address(0), "Ownable: <span class="reserved">new</span> owner is the zero address");
<br>
<span class="line">1903</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emit OwnershipTransferred(_owner, <span class="reserved">new</span>Owner);
<br>
<span class="line">1904</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_owner = <span class="reserved">new</span>Owner;
<br>
<span class="line">1905</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1906</span> }
<br>
<span class="line">1907</span> 
<br>
<span class="line">1908</span> <span class="comment">// File: contracts/WickedCraniums.sol
</span><br>
<span class="line">1909</span> 
<br>
<span class="line">1910</span> pragma solidity 0.7.0;
<br>
<span class="line">1911</span> 
<br>
<span class="line">1912</span> <span class="comment">/**
</span><br>
<span class="line">1913</span> <span class="comment"> * @title Wickedcorncontract
</span><br>
<span class="line">1914</span> <span class="comment"> * @dev Extends ERC721 Non-Fungible Token Standard basic implementation
</span><br>
<span class="line">1915</span> <span class="comment"> */
</span><br>
<span class="line">1916</span> contract Wickedcornis ERC721, Ownable {
<br>
<span class="line">1917</span> &nbsp;&nbsp;&nbsp;&nbsp;using SafeMath <span class="reserved">for</span> uint256;
<br>
<span class="line">1918</span> 
<br>
<span class="line">1919</span> &nbsp;&nbsp;&nbsp;&nbsp;string <span class="reserved">public</span> PROV = "b80d60a4defcca5af3ed652343434389b9400659c89da2b2725b32f8686d4a";
<br>
<span class="line">1920</span> &nbsp;&nbsp;&nbsp;&nbsp;uint256 public constant craniumPrice = 60000000000000000; <span class="comment">// 0.06 ETH
</span><br>
<span class="line">1921</span> &nbsp;&nbsp;&nbsp;&nbsp;uint <span class="reserved">public</span> <span class="reserved">constant</span> maxCraniumPurchase = 100;
<br>
<span class="line">1922</span> &nbsp;&nbsp;&nbsp;&nbsp;uint256 <span class="reserved">public</span> MAX_corn= 10762;
<br>
<span class="line">1923</span> &nbsp;&nbsp;&nbsp;&nbsp;bool <span class="reserved">public</span> saleIsActive = <span class="reserved">false</span>;
<br>
<span class="line">1924</span> 
<br>
<span class="line">1925</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">constructor</span>() ERC721("TheWickedCraniums", "TWC") {
<br>
<span class="line">1926</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1927</span> 
<br>
<span class="line">1928</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> withdraw() <span class="reserved">public</span> onlyOwner {
<br>
<span class="line">1929</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint balance = address(this).balance;
<br>
<span class="line">1930</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">msg</span>.sender.transfer(balance);
<br>
<span class="line">1931</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1932</span> 
<br>
<span class="line">1933</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> reserveCraniums() <span class="reserved">public</span> onlyOwner {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
<span class="line">1934</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint supply = totalSupply();
<br>
<span class="line">1935</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint i;
<br>
<span class="line">1936</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">for</span> (i = 0; i &lt; 40; i++) {
<br>
<span class="line">1937</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_safeMint(msg.sender, supply + i);
<br>
<span class="line">1938</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1939</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1940</span> &nbsp;&nbsp;&nbsp;&nbsp;
<br>
<span class="line">1941</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> flipSaleState() <span class="reserved">public</span> onlyOwner {
<br>
<span class="line">1942</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saleIsActive = !saleIsActive;
<br>
<span class="line">1943</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1944</span> &nbsp;&nbsp;&nbsp;&nbsp;
<br>
<span class="line">1945</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> setBaseURI(string memory baseURI) <span class="reserved">public</span> onlyOwner {
<br>
<span class="line">1946</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_setBaseURI(baseURI);
<br>
<span class="line">1947</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1948</span> 
<br>
<span class="line">1949</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">function</span> mintCraniums(uint numberOfTokens) <span class="reserved">public</span> payable {
<br>
<span class="line">1950</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(saleIsActive, "Sale must be active to mint Craniums");
<br>
<span class="line">1951</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(numberOfTokens &lt;= maxCraniumPurchase, "Can only mint 100 tokens at a time");
<br>
<span class="line">1952</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(totalSupply().add(numberOfTokens) &lt;= MAX_CRANIUMS, "Purchase would exceed max supply of Craniums");
<br>
<span class="line">1953</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">require</span>(craniumPrice.mul(numberOfTokens) &lt;= <span class="reserved">msg</span>.value, "Ether value sent is not correct");
<br>
<span class="line">1954</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
<span class="line">1955</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">for</span>(uint i = 0; i &lt; numberOfTokens; i++) {
<br>
<span class="line">1956</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint mintIndex = totalSupply();
<br>
<span class="line">1957</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="reserved">if</span> (totalSupply() &lt; MAX_CRANIUMS) {
<br>
<span class="line">1958</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_safeMint(msg.sender, mintIndex);
<br>
<span class="line">1959</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1960</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1961</span> &nbsp;&nbsp;&nbsp;&nbsp;}
<br>
<span class="line">1962</span> 
<br>
<span class="line">1963</span> }
<br>
<span class="line">1964</span> 
<br>
</code>
 
 

</body></html>